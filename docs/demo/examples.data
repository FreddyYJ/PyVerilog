#include "metron_tools.h"

//------------------------------------------------------------------------------

class Blockram {
public:
  Blockram() {
    readmemh("blockram.hex", memory, 0, 255);
  }

  logic<8> get_data() const {
    return data_out;
  }

  void tick(logic<8> address, logic<1> write, logic<8> data_in) {
    if (write) {
      memory[address] = data_in;
      data_out = data_in;
    }
    else {
      data_out = memory[address];
    }
  }

private:
  logic<8> memory[256];
  logic<8> data_out;
};

//------------------------------------------------------------------------------

class Checksum {
public:

  int get_checksum() const {
    return sum;
  }

  int get_done() const {
    return cursor == 256;
  }

  void tock(int reset) {
    logic<8> data = ram.get_data();

    ram.tick(cursor, 0, 0);
    tick(reset, data);
  }

private:

  void tick(int reset, logic<8> data) {
    if (reset) {
      cursor = 0;
      sum = 0;
    }
    else {
      if (cursor < 256) {
        cursor = cursor + 1;
        sum = sum + data;
      }
    }
  }

  int cursor;
  int sum;
  Blockram ram;
};

//------------------------------------------------------------------------------
A port of riscv-simple-sv (https://github.com/tilk/riscv-simple-sv) to Metron.
// RISC-V SiMPLE SV -- immediate generator
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef IMMEDIATE_GENERATOR_H
#define IMMEDIATE_GENERATOR_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

class immediate_generator {
 public:
  logic<32> inst;
  logic<32> immediate;

  // clang-format off
  // Immediate format
  //       31.............30........20.19........12.11.....11.10.........5.4..........1.0.....0
  // I = { {21{inst[31]}},                                     inst[30:25], inst[24:20]         };
  // S = { {21{inst[31]}},                                     inst[30:25], inst[11:7]          };
  // B = { {20{inst[31]}}, inst[7],                            inst[30:25], inst[11:8],   1'b0  };
  // U = { {1{inst[31]}},  inst[30:20], inst[19:12],                                      12'b0 };
  // J = { {12{inst[31]}},              inst[19:12], inst[20], inst[30:25], inst[24:21],  1'b0  };
  // clang-format on

  void tock() {
    using namespace rv_constants;
    // clang-format off
    immediate = b32(0b0);
    switch (b7(inst)) { // Opcode
      case OPCODE_LOAD:
      case OPCODE_LOAD_FP:
      case OPCODE_OP_IMM:
      case OPCODE_JALR: // I-type immediate
        immediate = cat(dup<21>(inst[31]), b6(inst, 25), b5(inst, 20)); break;
      case OPCODE_STORE_FP:
      case OPCODE_STORE: // S-type immediate
        immediate = cat(dup<21>(inst[31]), b6(inst, 25), b5(inst, 7)); break;
      case OPCODE_BRANCH: // B-type immediate
        immediate = cat(dup<20>(inst[31]), inst[7], b6(inst, 25), b4(inst, 8), b1(0b0)); break;
      case OPCODE_AUIPC:
      case OPCODE_LUI: // U-type immediate
        immediate = cat(inst[31], b11(inst, 20), b8(inst, 12), b12(0b0)); break;
      case OPCODE_JAL: // J-type immediate
        immediate = cat(dup<12>(inst[31]), b8(inst, 12), inst[20], b6(inst, 25), b4(inst, 21), b1(0b0)); break;
      default: immediate = b32(0b0); break;
    }
    // clang-format on
  }
};

#endif // IMMEDIATE_GENERATOR_H
// RISC-V SiMPLE SV -- single-cycle controller
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef SINGLECYCLE_CONTROL_H
#define SINGLECYCLE_CONTROL_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

class singlecycle_control {
 public:
  logic<7> inst_opcode;
  logic<1> take_branch;
  logic<1> pc_write_enable;
  logic<1> regfile_write_enable;
  logic<1> alu_operand_a_select;
  logic<1> alu_operand_b_select;
  logic<2> alu_op_type;
  logic<1> data_mem_read_enable;
  logic<1> data_mem_write_enable;
  logic<3> reg_writeback_select;
  logic<2> next_pc_select;

  void tock_next_pc_select() {
    using namespace rv_constants;
    // clang-format off
    switch (inst_opcode) {
      case OPCODE_BRANCH: next_pc_select = take_branch ? CTL_PC_PC_IMM : CTL_PC_PC4; break;
      case OPCODE_JALR:   next_pc_select = CTL_PC_RS1_IMM; break;
      case OPCODE_JAL:    next_pc_select = CTL_PC_PC_IMM; break;
      default:            next_pc_select = CTL_PC_PC4; break;
    }
    // clang-format on
  }

  void tock_pc_write_enable() { pc_write_enable = 0b1; }

  void tock_regfile_write_enable() {
    using namespace rv_constants;
    // clang-format off
    switch (inst_opcode) {
      case OPCODE_MISC_MEM: regfile_write_enable = 0; break;
      case OPCODE_STORE:    regfile_write_enable = 0; break;
      case OPCODE_BRANCH:   regfile_write_enable = 0; break;
      case OPCODE_LOAD:     regfile_write_enable = 1; break;
      case OPCODE_OP_IMM:   regfile_write_enable = 1; break;
      case OPCODE_AUIPC:    regfile_write_enable = 1; break;
      case OPCODE_OP:       regfile_write_enable = 1; break;
      case OPCODE_LUI:      regfile_write_enable = 1; break;
      case OPCODE_JALR:     regfile_write_enable = 1; break;
      case OPCODE_JAL:      regfile_write_enable = 1; break;
      default:              regfile_write_enable = b1(DONTCARE); break;
    }
    // clang-format on
  }

  void tock_alu_operand_a_select() {
    using namespace rv_constants;

    // clang-format off
    switch (inst_opcode) {
      case OPCODE_AUIPC:    alu_operand_a_select = CTL_ALU_A_PC; break;
      case OPCODE_JAL:      alu_operand_a_select = CTL_ALU_A_PC; break;

      case OPCODE_OP:       alu_operand_a_select = CTL_ALU_A_RS1; break;
      case OPCODE_LUI:      alu_operand_a_select = CTL_ALU_A_RS1; break;
      case OPCODE_BRANCH:   alu_operand_a_select = CTL_ALU_A_RS1; break;

      case OPCODE_LOAD:     alu_operand_a_select = CTL_ALU_A_RS1; break;
      case OPCODE_STORE:    alu_operand_a_select = CTL_ALU_A_RS1; break;
      case OPCODE_OP_IMM:   alu_operand_a_select = CTL_ALU_A_RS1; break;
      case OPCODE_JALR:     alu_operand_a_select = CTL_ALU_A_RS1; break;
      default:              alu_operand_a_select = b1(DONTCARE); break;
    }
    // clang-format on
  }

  void tock_alu_operand_b_select() {
    using namespace rv_constants;

    // clang-format off
    switch (inst_opcode) {
      case OPCODE_AUIPC:    alu_operand_b_select = CTL_ALU_B_IMM; break;
      case OPCODE_JAL:      alu_operand_b_select = CTL_ALU_B_IMM; break;

      case OPCODE_OP:       alu_operand_b_select = CTL_ALU_B_RS2; break;
      case OPCODE_LUI:      alu_operand_b_select = CTL_ALU_B_RS2; break;
      case OPCODE_BRANCH:   alu_operand_b_select = CTL_ALU_B_RS2; break;

      case OPCODE_LOAD:     alu_operand_b_select = CTL_ALU_B_IMM; break;
      case OPCODE_STORE:    alu_operand_b_select = CTL_ALU_B_IMM; break;
      case OPCODE_OP_IMM:   alu_operand_b_select = CTL_ALU_B_IMM; break;
      case OPCODE_JALR:     alu_operand_b_select = CTL_ALU_B_IMM; break;
      default:              alu_operand_b_select = b1(DONTCARE); break;
    }
    // clang-format on
  }

  void tock_alu_op_type() {
    using namespace rv_constants;

    // clang-format off
    switch (inst_opcode) {
      case OPCODE_AUIPC:    alu_op_type = CTL_ALU_ADD; break;
      case OPCODE_JAL:      alu_op_type = CTL_ALU_ADD; break;

      case OPCODE_OP:       alu_op_type = CTL_ALU_OP; break;
      case OPCODE_BRANCH:   alu_op_type = CTL_ALU_BRANCH; break;

      case OPCODE_LOAD:     alu_op_type = CTL_ALU_ADD; break;
      case OPCODE_STORE:    alu_op_type = CTL_ALU_ADD; break;
      case OPCODE_OP_IMM:   alu_op_type = CTL_ALU_OP_IMM; break;
      case OPCODE_JALR:     alu_op_type = CTL_ALU_ADD; break;
      default:              alu_op_type = b2(DONTCARE); break;
    }
    // clang-format on
  }

  void tock_data_mem_read_enable() {
    using namespace rv_constants;
    data_mem_read_enable = inst_opcode == OPCODE_LOAD;
  }

  void tock_data_mem_write_enable() {
    using namespace rv_constants;
    data_mem_write_enable = inst_opcode == OPCODE_STORE;
  }

  void tock_reg_writeback_select() {
    using namespace rv_constants;

    // clang-format off
    switch (inst_opcode) {
      case OPCODE_OP_IMM:   reg_writeback_select = CTL_WRITEBACK_ALU; break;
      case OPCODE_AUIPC:    reg_writeback_select = CTL_WRITEBACK_ALU; break;
      case OPCODE_OP:       reg_writeback_select = CTL_WRITEBACK_ALU; break;
      case OPCODE_LUI:      reg_writeback_select = CTL_WRITEBACK_IMM; break;
      case OPCODE_JALR:     reg_writeback_select = CTL_WRITEBACK_PC4; break;
      case OPCODE_JAL:      reg_writeback_select = CTL_WRITEBACK_PC4; break;
      case OPCODE_LOAD:     reg_writeback_select = CTL_WRITEBACK_DATA; break;
      default:              reg_writeback_select = b3(DONTCARE); break;
    }
    // clang-format on
  }
};

#endif // SINGLECYCLE_CONTROL_H
// RISC-V SiMPLE SV -- constants
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef CONSTANTS_H
#define CONSTANTS_H

#include "metron_tools.h"

namespace rv_constants {

//////////////////////////////////////////
//              Constants               //
//////////////////////////////////////////

//#define ON              0b1
//#define OFF             0b0
static const int ZERO = 0b00000000000000000000000000000000;

// Instruction opcodes
static const int OPCODE_LOAD = 0b0000011;
static const int OPCODE_LOAD_FP = 0b0000111;
static const int OPCODE_MISC_MEM = 0b0001111;
static const int OPCODE_OP_IMM = 0b0010011;
static const int OPCODE_AUIPC = 0b0010111;
static const int OPCODE_STORE = 0b0100011;
static const int OPCODE_STORE_FP = 0b0100111;
static const int OPCODE_OP = 0b0110011;
static const int OPCODE_LUI = 0b0110111;
static const int OPCODE_OP_FP = 0b1010011;
static const int OPCODE_BRANCH = 0b1100011;
static const int OPCODE_JALR = 0b1100111;
static const int OPCODE_JAL = 0b1101111;
static const int OPCODE_SYSTEM = 0b1110011;

// Interpretations of the "funct3" field
static const int FUNCT3_ALU_ADD_SUB = 0b000;
static const int FUNCT3_ALU_SLL = 0b001;
static const int FUNCT3_ALU_SLT = 0b010;
static const int FUNCT3_ALU_SLTU = 0b011;
static const int FUNCT3_ALU_XOR = 0b100;
static const int FUNCT3_ALU_SHIFTR = 0b101;
static const int FUNCT3_ALU_OR = 0b110;
static const int FUNCT3_ALU_AND = 0b111;

// Interpretations of the "funct3" field for extension M
static const int FUNCT3_ALU_MUL = 0b000;
static const int FUNCT3_ALU_MULH = 0b001;
static const int FUNCT3_ALU_MULHSU = 0b010;
static const int FUNCT3_ALU_MULHU = 0b011;
static const int FUNCT3_ALU_DIV = 0b100;
static const int FUNCT3_ALU_DIVU = 0b101;
static const int FUNCT3_ALU_REM = 0b110;
static const int FUNCT3_ALU_REMU = 0b111;

// Interpretations of the "funct7" field for extension F
static const int FUNCT7_FPALU_ADD = 0b0000000;
static const int FUNCT7_FPALU_SUB = 0b0000100;
static const int FUNCT7_FPALU_MUL = 0b0001000;
static const int FUNCT7_FPALU_DIV = 0b0001100;
static const int FUNCT7_FPALU_SQRT = 0b0101100;
static const int FUNCT7_FPALU_SIGN = 0b0010000;
static const int FUNCT7_FPALU_MINMAX = 0b0010100;
static const int FUNCT7_FPALU_CVT_W = 0b1100000;
static const int FUNCT7_FPALU_MV_X = 0b1110000;
static const int FUNCT7_FPALU_COMP = 0b1010000;
static const int FUNCT7_FPALU_CLASS = 0b1110000;
static const int FUNCT7_FPALU_CVT_S = 0b1101000;
static const int FUNCT7_FPALU_MV_W = 0b1111000;

// Interpretations of the "funct3" field for extension F (rounding modes)
static const int FUNCT3_ROUND_RNE = 0b000;
static const int FUNCT3_ROUND_RTZ = 0b001;
static const int FUNCT3_ROUND_RDN = 0b010;
static const int FUNCT3_ROUND_RUP = 0b011;
static const int FUNCT3_ROUND_RMM = 0b100;
static const int FUNCT3_ROUND_DYN = 0b111;

// Interpretations of the "funct3" field for loads and stores
static const int FUNCT3_MEM_BYTE = 0b000;
static const int FUNCT3_MEM_HALF = 0b001;
static const int FUNCT3_MEM_WORD = 0b010;
static const int FUNCT3_MEM_BYTE_U = 0b100;
static const int FUNCT3_MEM_HALF_U = 0b101;

// Interpretations of the "funct3" field for branches
static const int FUNCT3_BRANCH_EQ = 0b000;
static const int FUNCT3_BRANCH_NE = 0b001;
static const int FUNCT3_BRANCH_LT = 0b100;
static const int FUNCT3_BRANCH_GE = 0b101;
static const int FUNCT3_BRANCH_LTU = 0b110;
static const int FUNCT3_BRANCH_GEU = 0b111;

// Interpretations of the "funct3" field for system opcode
static const int FUNCT3_SYSTEM_ENV = 0b000;
static const int FUNCT3_SYSTEM_CSRRW = 0b001;
static const int FUNCT3_SYSTEM_CSRRS = 0b010;
static const int FUNCT3_SYSTEM_CSRRC = 0b011;
static const int FUNCT3_SYSTEM_CSRRWI = 0b101;
static const int FUNCT3_SYSTEM_CSRRSS = 0b110;
static const int FUNCT3_SYSTEM_CSRRCI = 0b111;

// ALU operations
static const int ALU_ADD = 0b00001;
static const int ALU_SUB = 0b00010;
static const int ALU_SLL = 0b00011;
static const int ALU_SRL = 0b00100;
static const int ALU_SRA = 0b00101;
static const int ALU_SEQ = 0b00110;
static const int ALU_SLT = 0b00111;
static const int ALU_SLTU = 0b01000;
static const int ALU_XOR = 0b01001;
static const int ALU_OR = 0b01010;
static const int ALU_AND = 0b01011;
static const int ALU_MUL = 0b01100;
static const int ALU_MULH = 0b01101;
static const int ALU_MULHSU = 0b01110;
static const int ALU_MULHU = 0b01111;
static const int ALU_DIV = 0b10000;
static const int ALU_DIVU = 0b10001;
static const int ALU_REM = 0b10010;
static const int ALU_REMU = 0b10011;

// ALU op types
static const int CTL_ALU_ADD = 0b00;
static const int CTL_ALU_BRANCH = 0b01;
static const int CTL_ALU_OP = 0b10;
static const int CTL_ALU_OP_IMM = 0b11;

// Register data sources
static const int CTL_WRITEBACK_ALU = 0b000;
static const int CTL_WRITEBACK_DATA = 0b001;
static const int CTL_WRITEBACK_PC4 = 0b010;
static const int CTL_WRITEBACK_IMM = 0b011;

// ALU 1st operand source
static const int CTL_ALU_A_RS1 = 0b0;
static const int CTL_ALU_A_PC = 0b1;

// ALU 2nd operand source
static const int CTL_ALU_B_RS2 = 0b0;
static const int CTL_ALU_B_IMM = 0b1;

// PC source
static const int CTL_PC_PC4 = 0b00;
static const int CTL_PC_PC_IMM = 0b01;
static const int CTL_PC_RS1_IMM = 0b10;
static const int CTL_PC_PC4_BR = 0b11;

// PC source in multicycle
static const int MC_CTL_PC_ALU_RES = 0b0;
static const int MC_CTL_PC_ALU_OUT = 0b1;

// ALU 2nd operand source in multicycle
static const int MC_CTL_ALU_B_RS2 = 0b00;
static const int MC_CTL_ALU_B_IMM = 0b01;
static const int MC_CTL_ALU_B_4 = 0b10;

};  // namespace rv_constants

#endif // CONSTANTS_H
// RISC-V SiMPLE SV -- multiplexer module
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef MULTIPLEXER8_H
#define MULTIPLEXER8_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

template <int WIDTH = 32>
class multiplexer8 {
 public:
  logic<WIDTH> in0;
  logic<WIDTH> in1;
  logic<WIDTH> in2;
  logic<WIDTH> in3;
  logic<WIDTH> in4;
  logic<WIDTH> in5;
  logic<WIDTH> in6;
  logic<WIDTH> in7;
  logic<3> sel;
  logic<WIDTH> out;

  void tock() {
    // clang-format off
    switch (sel) {
      case 0:  out = in0; break;
      case 1:  out = in1; break;
      case 2:  out = in2; break;
      case 3:  out = in3; break;
      case 4:  out = in4; break;
      case 5:  out = in5; break;
      case 6:  out = in6; break;
      case 7:  out = in7; break;
      default: out = bx<WIDTH>(DONTCARE); break;
    }
    // clang-format on
  }
};

#endif // MULTIPLEXER8_H
// RISC-V SiMPLE SV -- common configuration for testbench
// BSD 3-Clause License
// (c) 2017-2021, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef CONFIG_H
#define CONFIG_H

#include "metron_tools.h"

namespace rv_config {

// Select ISA extensions
// `define M_MODULE    // multiplication and division

//////////////////////////////////////////
//              Memory config           //
//////////////////////////////////////////

// Program counter initial value
static const unsigned int INITIAL_PC = 0x00400000;

// Instruction memory
static const unsigned int TEXT_BEGIN = INITIAL_PC;
static const unsigned int TEXT_BITS = 16;
static const unsigned int TEXT_WIDTH = (1 << TEXT_BITS);
static const unsigned int TEXT_END = (TEXT_BEGIN + TEXT_WIDTH - 1);

// Data memory
static const unsigned int DATA_BEGIN = 0x80000000;
static const unsigned int DATA_BITS = 17;
static const unsigned int DATA_WIDTH = (1 << DATA_BITS);
static const unsigned int DATA_END = (DATA_BEGIN + DATA_WIDTH - 1);

static const char* TEXT_HEX = "add.text.vh";
static const char* DATA_HEX = "add.data.vh";

};  // namespace rv_config

#endif // CONFIG_H
// RISC-V SiMPLE SV -- register file
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef REGFILE_H
#define REGFILE_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

class regfile {
 public:
  logic<1> write_enable;
  logic<5> rd_address;
  logic<5> rs1_address;
  logic<5> rs2_address;
  logic<32> rd_data;
  logic<32> rs1_data;
  logic<32> rs2_data;

 private:
  // 32 registers of 32-bit width
  logic<32> _register[32];

 public:
  // Read ports for rs1 and rs1
  void tock1() {
    rs1_data = _register[rs1_address];
    rs2_data = _register[rs2_address];
  }

  // Register x0 is always 0
  regfile() { _register[0] = b32(0b0); }

  void tock() { tick(); }

 private:
  // Write port for rd
  void tick() {
    if (write_enable)
      if (rd_address != b5(0b0)) _register[rd_address] = rd_data;
  }
};

#endif // REGFILE_H
// RISC-V SiMPLE SV -- instruction decoder
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef INSTRUCTION_DECODER_H
#define INSTRUCTION_DECODER_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

class instruction_decoder {
 public:
  logic<32> inst;
  logic<7> inst_opcode;
  logic<3> inst_funct3;
  logic<7> inst_funct7;
  logic<5> inst_rd;
  logic<5> inst_rs1;
  logic<5> inst_rs2;

  void tock() {
    inst_opcode = b7(inst, 0);
    inst_funct3 = b3(inst, 12);
    inst_funct7 = b7(inst, 25);
    inst_rd = b5(inst, 7);
    inst_rs1 = b5(inst, 15);
    inst_rs2 = b5(inst, 20);
  }
};

#endif // INSTRUCTION_DECODER_H
// RISC-V SiMPLE SV -- Single-cycle RISC-V core
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef RISCV_CORE_H
#define RISCV_CORE_H

#include "config.h"
#include "constants.h"
#include "data_memory_interface.h"
#include "metron_tools.h"
#include "singlecycle_ctlpath.h"
#include "singlecycle_datapath.h"

class riscv_core {
 public:
  logic<1> reset;
  logic<32> bus_address;
  logic<32> bus_read_data;
  logic<32> bus_write_data;
  logic<4> bus_byte_enable;
  logic<1> bus_read_enable;
  logic<1> bus_write_enable;

  logic<32> inst;
  logic<32> pc;

  void tock_pc() {
    datapath.tock_pc();
    pc = datapath.pc;
  }

  void tock_execute() {
    datapath.inst = inst;
    datapath.tock_instruction_decoder();
    datapath.tock_immediate_generator();

    ctlpath.inst_opcode = datapath.inst_opcode;
    ctlpath.inst_funct3 = datapath.inst_funct3;
    ctlpath.inst_funct7 = datapath.inst_funct7;

    ctlpath.tock_alu_function();
    ctlpath.tock_alu_operand_select();

    datapath.alu_function = ctlpath.alu_function;
    datapath.alu_operand_a_select = ctlpath.alu_operand_a_select;
    datapath.alu_operand_b_select = ctlpath.alu_operand_b_select;

    datapath.tock_reg_read();
    datapath.tock_mux_operand_a();
    datapath.tock_mux_operand_b();
    datapath.tock_alu();

    ctlpath.tock_data_mem_enable();
    datapath.tock_data_mem_write_data();
    dmem.read_enable = ctlpath.data_mem_read_enable;
    dmem.write_enable = ctlpath.data_mem_write_enable;
    dmem.data_format = datapath.inst_funct3;
    dmem.address = datapath.data_mem_address;
    dmem.write_data = datapath.data_mem_write_data;
    dmem.tock_bus();

    ctlpath.alu_result_equal_zero = datapath.alu_result_equal_zero;
    ctlpath.tock_pc_write_enable();
    ctlpath.tock_regfile_write_enable();
    ctlpath.tock_reg_writeback_select();
    ctlpath.tock_next_pc_select();

    //----------

    bus_address = dmem.bus_address;
    bus_write_data = dmem.bus_write_data;
    bus_byte_enable = dmem.bus_byte_enable;
    bus_read_enable = dmem.bus_read_enable;
    bus_write_enable = dmem.bus_write_enable;
  }

  void tock_writeback() {
    dmem.bus_read_data = bus_read_data;
    dmem.tock_read_data();

    datapath.next_pc_select = ctlpath.next_pc_select;
    datapath.tock_adder_pc_plus_4();
    datapath.tock_adder_pc_plus_immediate();
    datapath.tock_mux_next_pc_select();

    datapath.reset = reset;
    datapath.pc_write_enable = ctlpath.pc_write_enable;
    datapath.tock_program_counter();

    datapath.reg_writeback_select = ctlpath.reg_writeback_select;
    datapath.data_mem_read_data = dmem.read_data;
    datapath.tock_mux_reg_writeback();

    datapath.regfile_write_enable = ctlpath.regfile_write_enable;
    datapath.tock_reg_writeback();
  }

  //----------------------------------------

 private:
  singlecycle_datapath datapath;
  singlecycle_ctlpath ctlpath;
  data_memory_interface dmem;
};

#endif // RISCV_CORE_H
// RISC-V SiMPLE SV -- multiplexer module
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef MULTIPLEXER4_H
#define MULTIPLEXER4_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

template <int WIDTH = 32>
class multiplexer4 {
 public:
  logic<WIDTH> in0;
  logic<WIDTH> in1;
  logic<WIDTH> in2;
  logic<WIDTH> in3;
  logic<2> sel;
  logic<WIDTH> out;

  void tock() {
    switch (sel) {
      case 0:
        out = in0;
        break;
      case 1:
        out = in1;
        break;
      case 2:
        out = in2;
        break;
      case 3:
        out = in3;
        break;
      default:
        out = bx<WIDTH>(DONTCARE);
        break;
    }
  }
};

#endif // MULTIPLEXER4_H
// RISC-V SiMPLE SV -- adder module
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef ADDER_H
#define ADDER_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

template <int WIDTH = 32>
class adder {
 public:
  logic<WIDTH> operand_a;
  logic<WIDTH> operand_b;
  logic<WIDTH> result;

  void tock() { result = operand_a + operand_b; }
};

#endif // ADDER_H
// RISC-V SiMPLE SV -- data memory interface
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef DATA_MEMORY_INTERFACE_H
#define DATA_MEMORY_INTERFACE_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

class data_memory_interface {
 public:
  logic<1> read_enable;
  logic<1> write_enable;
  logic<3> data_format;
  logic<32> address;
  logic<32> write_data;
  logic<32> read_data;

  logic<32> bus_address;
  logic<32> bus_read_data;
  logic<32> bus_write_data;
  logic<4> bus_byte_enable;
  logic<1> bus_read_enable;
  logic<1> bus_write_enable;

 private:
  logic<32> position_fix;
  logic<32> sign_fix;

 public:
  void tock_bus() {
    bus_address = address;
    bus_write_enable = write_enable;
    bus_read_enable = read_enable;
    bus_write_data = write_data << (8 * b2(address));

    // calculate byte enable
    // clang-format off
    switch (b2(data_format)) {
      case 0b00: bus_byte_enable = b4(0b0001) << b2(address); break;
      case 0b01: bus_byte_enable = b4(0b0011) << b2(address); break;
      case 0b10: bus_byte_enable = b4(0b1111) << b2(address); break;
      default:   bus_byte_enable = b4(0b0000); break;
    }
    // clang-format on
  }

  // correct for unaligned accesses
  void tock_read_data() {
    position_fix = b32(bus_read_data >> (8 * b2(address)));

    // sign-extend if necessary
    // clang-format off
    switch (b2(data_format)) {
      case 0b00: sign_fix = cat(dup<24>(b1(~data_format[2] & position_fix[7])), b8(position_fix)); break;
      case 0b01: sign_fix = cat(dup<16>(b1(~data_format[2] & position_fix[15])), b16(position_fix)); break;
      case 0b10: sign_fix = b32(position_fix); break;
      default:   sign_fix = b32(DONTCARE); break;
    }
    // clang-format on

    read_data = sign_fix;
  }
};

#endif // DATA_MEMORY_INTERFACE_H
// RISC-V SiMPLE SV -- data memory bus
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef EXAMPLE_DATA_MEMORY_BUS
#define EXAMPLE_DATA_MEMORY_BUS

#include "config.h"
#include "constants.h"
#include "example_data_memory.h"
#include "metron_tools.h"

class example_data_memory_bus {
 public:
  logic<32> address;     // in
  logic<32> read_data;   // out
  logic<32> write_data;  // in
  logic<4> byte_enable;  // in
  logic<1> read_enable;  // in
  logic<1> write_enable; // in

 private:
  example_data_memory data_memory;

 public:
  void tock() {
    logic<1> is_data_memory =
        address >= rv_config::DATA_BEGIN && rv_config::DATA_END >= address;

    data_memory.address = bx<rv_config::DATA_BITS - 2>(address, 2);
    data_memory.byteena = byte_enable;
    data_memory.data = write_data;
    data_memory.wren = write_enable & is_data_memory;
    data_memory.tock();

    logic<32> fetched = data_memory.q;
    read_data = read_enable && is_data_memory ? fetched : b32(DONTCARE);
  }
};

#endif // EXAMPLE_DATA_MEMORY_BUS
// RISC-V SiMPLE SV -- ALU controller module
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef ALU_CONTROL_H
#define ALU_CONTROL_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

class alu_control {
 public:
  logic<2> alu_op_type;
  logic<3> inst_funct3;
  logic<7> inst_funct7;
  logic<5> alu_function;

 private:
  logic<5> default_funct;
  logic<5> secondary_funct;
  logic<5> op_funct;
  logic<5> op_imm_funct;
  logic<5> branch_funct;

 public:
  // clang-format off
  void tock_alu_function() {
    using namespace rv_constants;

    switch (inst_funct3) {
      case FUNCT3_ALU_ADD_SUB: default_funct = ALU_ADD; break;
      case FUNCT3_ALU_SLL:     default_funct = ALU_SLL; break;
      case FUNCT3_ALU_SLT:     default_funct = ALU_SLT; break;
      case FUNCT3_ALU_SLTU:    default_funct = ALU_SLTU; break;
      case FUNCT3_ALU_XOR:     default_funct = ALU_XOR; break;
      case FUNCT3_ALU_SHIFTR:  default_funct = ALU_SRL; break;
      case FUNCT3_ALU_OR:      default_funct = ALU_OR; break;
      case FUNCT3_ALU_AND:     default_funct = ALU_AND; break;
      default:                 default_funct = b5(DONTCARE); break;
    }

    switch (inst_funct3) {
      case FUNCT3_ALU_ADD_SUB: secondary_funct = ALU_SUB; break;
      case FUNCT3_ALU_SHIFTR:  secondary_funct = ALU_SRA; break;
      default:                 secondary_funct = b5(DONTCARE); break;
    }

    if (inst_funct7[5])
      op_funct = secondary_funct;
    else
      op_funct = default_funct;

    if (inst_funct7[5] && b2(inst_funct3) == b2(0b01))
      op_imm_funct = secondary_funct;
    else
      op_imm_funct = default_funct;

    switch (inst_funct3) {
      case FUNCT3_BRANCH_EQ:  branch_funct = ALU_SEQ; break;
      case FUNCT3_BRANCH_NE:  branch_funct = ALU_SEQ; break;
      case FUNCT3_BRANCH_LT:  branch_funct = ALU_SLT; break;
      case FUNCT3_BRANCH_GE:  branch_funct = ALU_SLT; break;
      case FUNCT3_BRANCH_LTU: branch_funct = ALU_SLTU; break;
      case FUNCT3_BRANCH_GEU: branch_funct = ALU_SLTU; break;
      default:                branch_funct = b5(DONTCARE); break;
    }

    switch (alu_op_type) {
      case CTL_ALU_ADD:    alu_function = ALU_ADD; break;
      case CTL_ALU_OP:     alu_function = op_funct; break;
      case CTL_ALU_OP_IMM: alu_function = op_imm_funct; break;
      case CTL_ALU_BRANCH: alu_function = branch_funct; break;
      default:             alu_function = b5(DONTCARE); break;
    }
  }
  // clang-format on
};

#endif // ALU_CONTROL_H
// RISC-V SiMPLE SV -- multiplexer module
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef MULTIPLEXER2_H
#define MULTIPLEXER2_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

template <int WIDTH = 32>
class multiplexer2 {
 public:
  logic<WIDTH> in0;
  logic<WIDTH> in1;
  logic<1> sel;
  logic<WIDTH> out;

  void tock() {
    switch (sel) {
      case 0:
        out = in0;
        break;
      case 1:
        out = in1;
        break;
      default:
        out = bx<WIDTH>(DONTCARE);
        break;
    }
  }
};

#endif // MULTIPLEXER2_H
// RISC-V SiMPLE SV -- ALU module
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef ALU_H
#define ALU_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

class alu {
 public:
  logic<5> alu_function;
  logic<32> operand_a;
  logic<32> operand_b;
  logic<32> result;
  logic<1> result_equal_zero;

  void tock() {
    using namespace rv_constants;

    // clang-format off
    switch (alu_function) {
      case ALU_ADD:  result = operand_a + operand_b; break;
      case ALU_SUB:  result = operand_a - operand_b; break;
      case ALU_SLL:  result = operand_a << b5(operand_b); break;
      case ALU_SRL:  result = operand_a >> b5(operand_b); break;
      case ALU_SRA:  result = sra(operand_a, b5(operand_b)); break;
      case ALU_SEQ:  result = cat(b31(0b0), b1(operand_a == operand_b)); break;
      case ALU_SLT:  result = cat(b31(0b0), b1(signed(operand_a) < signed(operand_b))); break;
      case ALU_SLTU: result = cat(b31(0b0), b1(unsigned(operand_a) < unsigned(operand_b))); break;
      case ALU_XOR:  result = operand_a ^ operand_b; break;
      case ALU_OR:   result = operand_a | operand_b; break;
      case ALU_AND:  result = operand_a & operand_b; break;
      default:       result = b32(ZERO); break;
    }
    // clang-format on

    result_equal_zero = (result == b32(0));
  }
};

#endif // ALU_H
// RISC-V SiMPLE SV -- text memory model
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef EXAMPLE_TEXT_MEMORY_H
#define EXAMPLE_TEXT_MEMORY_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

class example_text_memory {
 public:
  example_text_memory() {
    std::string s;
    value_plusargs("text_file=%s", s);
    readmemh(s, mem);
  }

  logic<rv_config::TEXT_BITS - 2> address;
  logic<32> q;
  void tock_q() { q = mem[address]; }

 private:
  logic<32> mem[pow2(rv_config::TEXT_BITS - 2)];
};

#endif // EXAMPLE_TEXT_MEMORY_H
// RISC-V SiMPLE SV -- control path
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef SINGLECYCLE_CTLPATH_H
#define SINGLECYCLE_CTLPATH_H

#include "alu_control.h"
#include "config.h"
#include "constants.h"
#include "control_transfer.h"
#include "metron_tools.h"
#include "singlecycle_control.h"

class singlecycle_ctlpath {
 public:
  logic<7> inst_opcode;
  logic<3> inst_funct3;
  logic<7> inst_funct7;
  logic<1> alu_result_equal_zero;

  logic<1> pc_write_enable;
  logic<1> regfile_write_enable;
  logic<1> alu_operand_a_select;
  logic<1> alu_operand_b_select;
  logic<1> data_mem_read_enable;
  logic<1> data_mem_write_enable;
  logic<3> reg_writeback_select;
  logic<5> alu_function;
  logic<2> next_pc_select;

  void tock_alu_function() {
    control.inst_opcode = inst_opcode;
    control.tock_alu_op_type();
    alu_ctrl.alu_op_type = control.alu_op_type;
    alu_ctrl.inst_funct3 = inst_funct3;
    alu_ctrl.inst_funct7 = inst_funct7;
    alu_ctrl.tock_alu_function();
    alu_function = alu_ctrl.alu_function;
  }

  void tock_alu_operand_select() {
    control.tock_alu_operand_a_select();
    control.tock_alu_operand_b_select();
    alu_operand_a_select = control.alu_operand_a_select;
    alu_operand_b_select = control.alu_operand_b_select;
  }

  void tock_data_mem_enable() {
    control.tock_data_mem_read_enable();
    control.tock_data_mem_write_enable();
    data_mem_read_enable = control.data_mem_read_enable;
    data_mem_write_enable = control.data_mem_write_enable;
  }

  void tock_pc_write_enable() {
    control.tock_pc_write_enable();
    pc_write_enable = control.pc_write_enable;
  }

  void tock_regfile_write_enable() {
    control.tock_regfile_write_enable();
    regfile_write_enable = control.regfile_write_enable;
  }

  void tock_reg_writeback_select() {
    control.tock_reg_writeback_select();
    reg_writeback_select = control.reg_writeback_select;
  }

  void tock_next_pc_select() {
    transfer.result_equal_zero = alu_result_equal_zero;
    transfer.inst_funct3 = inst_funct3;
    transfer.tock_take_branch();
    control.take_branch = transfer.take_branch;
    control.tock_next_pc_select();
    next_pc_select = control.next_pc_select;
  }

  //----------------------------------------

 private:
  singlecycle_control control;
  control_transfer transfer;
  alu_control alu_ctrl;
};

#endif // SINGLECYCLE_CTLPATH_H
// RISC-V SiMPLE SV -- generic register
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef REGISTER_H
#define REGISTER_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

template <int WIDTH = 32, int INITIAL = 0>
class single_register {
 public:
  logic<1> reset;
  logic<1> write_enable;
  logic<WIDTH> next;
  logic<WIDTH> value;

  single_register() { value = INITIAL; }

  void tock() { tick(); }

 private:
  void tick() {
    if (reset)
      value = INITIAL;
    else if (write_enable)
      value = next;
  }
};

#endif // REGISTER_H
// RISC-V SiMPLE SV -- Toplevel
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef TOPLEVEL_H
#define TOPLEVEL_H

#include "config.h"
#include "constants.h"
#include "example_data_memory_bus.h"
#include "example_text_memory_bus.h"
#include "metron_tools.h"
#include "riscv_core.h"

template <int foobar = 2>
class toplevel {
 public:
  logic<1> reset;
  logic<32> bus_read_data;
  logic<32> bus_address;
  logic<32> bus_write_data;
  logic<4> bus_byte_enable;
  logic<1> bus_read_enable;
  logic<1> bus_write_enable;

  logic<32> inst;
  logic<32> pc;

  //----------------------------------------

  void tock(int bogus_param) {
    core.reset = reset;
    core.tock_pc();

    text_memory_bus.address = core.pc;
    text_memory_bus.tock_read_data();

    core.inst = text_memory_bus.read_data;
    core.tock_execute();

    data_memory_bus.address = core.bus_address;
    data_memory_bus.read_enable = core.bus_read_enable;
    data_memory_bus.write_enable = core.bus_write_enable;
    data_memory_bus.byte_enable = core.bus_byte_enable;
    data_memory_bus.write_data = core.bus_write_data;
    data_memory_bus.tock();

    core.bus_read_data = data_memory_bus.read_data;
    core.tock_writeback();

    //----------

    bus_read_data = data_memory_bus.read_data;
    bus_address = core.bus_address;
    bus_write_data = core.bus_write_data;
    bus_byte_enable = core.bus_byte_enable;
    bus_read_enable = core.bus_read_enable;
    bus_write_enable = core.bus_write_enable;
    inst = text_memory_bus.read_data;
    pc = core.pc;
  }

  //----------------------------------------

 private:
  riscv_core core;
  example_text_memory_bus text_memory_bus;
  example_data_memory_bus data_memory_bus;
};

#endif // TOPLEVEL_H
// RISC-V SiMPLE SV -- control transfer unit
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef CONTROL_TRANSFER_H
#define CONTROL_TRANSFER_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

class control_transfer {
 public:
  logic<1> result_equal_zero;
  logic<3> inst_funct3;
  logic<1> take_branch;

  void tock_take_branch() {
    using namespace rv_constants;
    // clang-format off
    switch (inst_funct3) {
      case FUNCT3_BRANCH_EQ:  take_branch = !result_equal_zero; break;
      case FUNCT3_BRANCH_NE:  take_branch = result_equal_zero; break;
      case FUNCT3_BRANCH_LT:  take_branch = !result_equal_zero; break;
      case FUNCT3_BRANCH_GE:  take_branch = result_equal_zero; break;
      case FUNCT3_BRANCH_LTU: take_branch = !result_equal_zero; break;
      case FUNCT3_BRANCH_GEU: take_branch = result_equal_zero; break;
      default:                take_branch = b1(DONTCARE); break;
    }
    // clang-format on
  }
};

#endif // CONTROL_TRANSFER_H
// RISC-V SiMPLE SV -- data memory model
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef EXAMPLE_DATA_MEMORY_H
#define EXAMPLE_DATA_MEMORY_H

#include "config.h"
#include "constants.h"
#include "metron_tools.h"

class example_data_memory {
 public:
  logic<rv_config::DATA_BITS - 2> address;
  logic<32> q;
  logic<1> wren;
  logic<4> byteena;
  logic<32> data;

 private:
  /*#(* nomem2reg *)#*/
  logic<32> mem[pow2(rv_config::DATA_BITS - 2)];

 public:
  void tock() {
    q = mem[address];
    tick();
  }

 private:
  void tick() {
    if (wren) {
      // doing this slightly differently from rvsimple so we don't have to do
      // sub-array writes to mem.
      logic<32> mask = 0;
      if (byteena[0]) mask = mask | 0x000000FF;
      if (byteena[1]) mask = mask | 0x0000FF00;
      if (byteena[2]) mask = mask | 0x00FF0000;
      if (byteena[3]) mask = mask | 0xFF000000;
      mem[address] = (mem[address] & ~mask) | (data & mask);
    }
  }

 public:
  example_data_memory() {
    std::string s;
    value_plusargs("data_file=%s", s);
    readmemh(s, mem);
  }
};

#endif // EXAMPLE_DATA_MEMORY_H
// RISC-V SiMPLE SV -- program text memory bus
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef EXAMPLE_TEXT_MEMORY_BUS_H
#define EXAMPLE_TEXT_MEMORY_BUS_H

#include "config.h"
#include "constants.h"
#include "example_text_memory.h"
#include "metron_tools.h"

class example_text_memory_bus {
 public:
  logic<32> address;
  logic<32> read_data;

 private:
  example_text_memory text_memory;

 public:
  void tock_read_data() {
    text_memory.address = bx<rv_config::TEXT_BITS - 2>(address, 2);
    text_memory.tock_q();
    logic<32> fetched = text_memory.q;
    read_data =
        (address >= rv_config::TEXT_BEGIN) && (rv_config::TEXT_END >= address)
            ? fetched
            : b32(DONTCARE);
  }
};

#endif // EXAMPLE_TEXT_MEMORY_BUS_H
// RISC-V SiMPLE SV -- single-cycle data path
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Brasília,
//                Marek Materzok, University of Wrocław

#ifndef SINGLECYCLE_DATAPATH_H
#define SINGLECYCLE_DATAPATH_H

#include "adder.h"
#include "alu.h"
#include "config.h"
#include "constants.h"
#include "immediate_generator.h"
#include "instruction_decoder.h"
#include "metron_tools.h"
#include "multiplexer2.h"
#include "multiplexer4.h"
#include "multiplexer8.h"
#include "regfile.h"
#include "register.h"

class singlecycle_datapath {
 public:
  logic<1> reset;
  logic<32> data_mem_read_data;
  logic<32> data_mem_address;
  logic<32> data_mem_write_data;

  logic<32> inst;
  logic<32> pc;
  logic<7> inst_opcode;
  logic<3> inst_funct3;
  logic<7> inst_funct7;
  logic<1> alu_result_equal_zero;

  // control signals
  logic<1> pc_write_enable;
  logic<1> regfile_write_enable;
  logic<1> alu_operand_a_select;
  logic<1> alu_operand_b_select;
  logic<3> reg_writeback_select;
  logic<2> next_pc_select;
  logic<5> alu_function;

 private:
  logic<32> rs1_data;
  logic<32> rs2_data;

  logic<5> inst_rd;
  logic<5> inst_rs1;
  logic<5> inst_rs2;

 public:
  //----------------------------------------

  void tock_pc() { pc = program_counter.value; }

  //----------------------------------------

  void tock_instruction_decoder() {
    idec.inst = inst;
    idec.tock();

    inst_opcode = idec.inst_opcode;
    inst_funct3 = idec.inst_funct3;
    inst_funct7 = idec.inst_funct7;
    inst_rd = idec.inst_rd;
    inst_rs1 = idec.inst_rs1;
    inst_rs2 = idec.inst_rs2;
  }

  //----------------------------------------

  void tock_immediate_generator() {
    igen.inst = inst;
    igen.tock();
  }

  //----------------------------------------

  void tock_reg_read() {
    regs.rd_address = idec.inst_rd;
    regs.rs1_address = idec.inst_rs1;
    regs.rs2_address = idec.inst_rs2;
    regs.tock1();
    rs1_data = regs.rs1_data;
    rs2_data = regs.rs2_data;
  }

  void tock_mux_operand_a() {
    mux_operand_a.sel = alu_operand_a_select;
    mux_operand_a.in0 = regs.rs1_data;
    mux_operand_a.in1 = program_counter.value;
    mux_operand_a.tock();
  }

  void tock_mux_operand_b() {
    mux_operand_b.sel = alu_operand_b_select;
    mux_operand_b.in0 = regs.rs2_data;
    mux_operand_b.in1 = igen.immediate;
    mux_operand_b.tock();
  }

  void tock_alu() {
    alu_core.alu_function = alu_function;
    alu_core.operand_a = mux_operand_a.out;
    alu_core.operand_b = mux_operand_b.out;
    alu_core.tock();
    alu_result_equal_zero = alu_core.result_equal_zero;
  }

  void tock_adder_pc_plus_4() {
    adder_pc_plus_4.operand_a = b32(0x00000004);
    adder_pc_plus_4.operand_b = program_counter.value;
    adder_pc_plus_4.tock();
  }

  void tock_adder_pc_plus_immediate() {
    adder_pc_plus_immediate.operand_a = program_counter.value;
    adder_pc_plus_immediate.operand_b = igen.immediate;
    adder_pc_plus_immediate.tock();
  }

  void tock_data_mem_write_data() {
    data_mem_address = alu_core.result;
    data_mem_write_data = regs.rs2_data;
  }

  void tock_mux_next_pc_select() {
    mux_next_pc_select.sel = next_pc_select;
    mux_next_pc_select.in0 = adder_pc_plus_4.result;
    mux_next_pc_select.in1 = adder_pc_plus_immediate.result;
    mux_next_pc_select.in2 = cat(b31(alu_core.result, 1), b1(0b0));
    mux_next_pc_select.in3 = b32(0b0);
    mux_next_pc_select.tock();
  }

  void tock_program_counter() {
    program_counter.reset = reset;
    program_counter.write_enable = pc_write_enable;
    program_counter.next = mux_next_pc_select.out;
    program_counter.tock();
  }

  void tock_mux_reg_writeback() {
    mux_reg_writeback.sel = reg_writeback_select;
    mux_reg_writeback.in0 = alu_core.result;
    mux_reg_writeback.in1 = data_mem_read_data;
    mux_reg_writeback.in2 = adder_pc_plus_4.result;
    mux_reg_writeback.in3 = igen.immediate;
    mux_reg_writeback.in4 = b32(0b0);
    mux_reg_writeback.in5 = b32(0b0);
    mux_reg_writeback.in6 = b32(0b0);
    mux_reg_writeback.in7 = b32(0b0);
    mux_reg_writeback.tock();
  }

  void tock_reg_writeback() {
    regs.write_enable = regfile_write_enable;
    regs.rd_data = mux_reg_writeback.out;
    regs.tock();
  }

  //----------------------------------------

 private:
  adder<32> adder_pc_plus_4;
  adder<32> adder_pc_plus_immediate;
  alu alu_core;
  multiplexer4<32> mux_next_pc_select;
  multiplexer2<32> mux_operand_a;
  multiplexer2<32> mux_operand_b;
  multiplexer8<32> mux_reg_writeback;
  single_register<32, rv_config::INITIAL_PC> program_counter;
  regfile regs;
  instruction_decoder idec;
  immediate_generator igen;
};

#endif // SINGLECYCLE_DATAPATH_H
Unfinished port of the Ibex RISC-V core to Metron.
// Copyright lowRISC contributors.
// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

/**
 * Slow Multiplier and Division
 *
 * Baugh-Wooley multiplier and Long Division
 */

#pragma once
#include "metron_tools.h"
#include "ibex_pkg.h"

struct ibex_multdiv_slow {

  logic<33> alu_operand_a_o;
  logic<33> alu_operand_b_o;
  logic<34> imd_val_d_o[2];
  logic<2>  imd_val_we_o;
  logic<32> multdiv_result_o;
  logic<1>  valid_o;

  enum class md_fsm_e : logic<3>::BASE {
    MD_IDLE, MD_ABS_A, MD_ABS_B, MD_COMP, MD_LAST, MD_CHANGE_SIGN, MD_FINISH
  };
  md_fsm_e md_state_q, md_state_d;

  logic<33> accum_window_q, accum_window_d;
  logic<1>  unused_imd_val0;
  logic<2>  unused_imd_val1;

  logic<33> res_adder_l;
  logic<33> res_adder_h;

  logic<5>  multdiv_count_q, multdiv_count_d;
  logic<33> op_b_shift_q, op_b_shift_d;
  logic<33> op_a_shift_q, op_a_shift_d;
  logic<33> op_a_ext, op_b_ext;
  logic<33> one_shift;
  logic<33> op_a_bw_pp, op_a_bw_last_pp;
  logic<32> b_0;
  logic<1>  sign_a, sign_b;
  logic<33> next_quotient;
  logic<32> next_remainder;
  logic<32> op_numerator_q, op_numerator_d;
  logic<1>  is_greater_equal;
  logic<1>  div_change_sign, rem_change_sign;
  logic<1>  div_by_zero_d, div_by_zero_q;
  logic<1>  multdiv_hold;
  logic<1>  multdiv_en;

  void tock4(logic<34> alu_adder_ext_i) {
     // (accum_window_q + op_a_shift_q)
    res_adder_l = b33(alu_adder_ext_i);
     // (accum_window_q + op_a_shift_q)>>1
    res_adder_h = b33(alu_adder_ext_i, 1);
  }

  /////////////////////
  // ALU Operand MUX //
  /////////////////////

  void tock7(logic<34> imd_val_q_i[2]) {
    // Intermediate value register shared with ALU
    imd_val_d_o[0]  = cat(b1(0b0), accum_window_d);
    imd_val_we_o[0] = ~multdiv_hold;
    accum_window_q  = b33(imd_val_q_i[0]);
    unused_imd_val0 = imd_val_q_i[0][33];

    imd_val_d_o[1]  = cat(b2(0b00), op_numerator_d);
    imd_val_we_o[1] = multdiv_en;
    op_numerator_q  = b32(imd_val_q_i[1]);
    unused_imd_val1 = b2(imd_val_q_i[1], 32);
  }

  void tock1(
    logic<1>  mult_en_i,
    logic<1>  div_en_i,
    logic<1>  mult_sel_i,
    logic<1>  div_sel_i,
    ibex_pkg::md_op_e   operator_i,
    logic<2>  signed_mode_i,
    logic<32> op_a_i,
    logic<32> op_b_i,
    logic<34> alu_adder_ext_i,
    logic<32> alu_adder_i,
    logic<1>  equal_to_zero_i,
    logic<1>  data_ind_timing_i,
    logic<34> imd_val_q_i[2],
    logic<1>  multdiv_ready_id_i) {
    using namespace ibex_pkg;
    alu_operand_a_o = accum_window_q;

    switch (operator_i) {
      case md_op_e::MD_OP_MULL: {
        alu_operand_b_o = op_a_bw_pp;
        break;
      }

      case md_op_e::MD_OP_MULH: {
        alu_operand_b_o = (md_state_q == md_fsm_e::MD_LAST) ? op_a_bw_last_pp : op_a_bw_pp;
        break;
      }

      case md_op_e::MD_OP_DIV:
      case md_op_e::MD_OP_REM: {
        switch (md_state_q) {
          case md_fsm_e::MD_IDLE: {
            // 0 - B = 0 iff B == 0
            alu_operand_a_o = cat(b32(0x0), b1(0b1));
            alu_operand_b_o = cat(~op_b_i, b1(0b1));
            break;
          }
          case md_fsm_e::MD_ABS_A: {
            // ABS(A) = 0 - A
            alu_operand_a_o = cat(b32(0x0), b1(0b1));
            alu_operand_b_o = cat(~op_a_i, b1(0b1));
            break;
          }
          case md_fsm_e::MD_ABS_B: {
            // ABS(B) = 0 - B
            alu_operand_a_o = cat(b32(0x0), b1(0b1));
            alu_operand_b_o = cat(~op_b_i, b1(0b1));
            break;
          }
          case md_fsm_e::MD_CHANGE_SIGN: {
            // ABS(Quotient) = 0 - Quotient (or Reminder)
            alu_operand_a_o = cat(b32(0x0), b1(0b1));
            alu_operand_b_o = cat(~b32(accum_window_q), b1(0b1));
            break;
          }
          default: {
            // Division
            alu_operand_a_o = cat(b32(accum_window_q), b1(0b1)); // it contains the remainder
            alu_operand_b_o = cat(~b32(op_b_shift_q), b1(0b1));     // -denominator two's compliment
            break;
         }
        }
        break;
      }
      default: {
        alu_operand_a_o = accum_window_q;
        alu_operand_b_o = cat(~b32(op_b_shift_q), b1(0b1));
        break;
      }
    }
  }

  void tock6(logic<32> op_a_i, logic<32> op_b_i, logic<2>  signed_mode_i) {
    // Multiplier partial product calculation
    b_0             = dup<32>(b1(op_b_shift_q));
    op_a_bw_pp      = cat( ~b1(op_a_shift_q, 32) & b1(op_b_shift_q),  (b32(op_a_shift_q) & b_0) );
    op_a_bw_last_pp = cat(  b1(op_a_shift_q, 32) & b1(op_b_shift_q), ~(b32(op_a_shift_q) & b_0) );

    // Sign extend the input operands
    sign_a   = b1(op_a_i, 31) & b1(signed_mode_i, 0);
    sign_b   = b1(op_b_i, 31) & b1(signed_mode_i, 1);

    op_a_ext = cat(sign_a, op_a_i);
    op_b_ext = cat(sign_b, op_b_i);

    // Divider calculations

    // The adder in the ALU computes Remainder - Divisor. If Remainder - Divisor >= 0,
    // is_greater_equal is true, the next Remainder is the subtraction result and the Quotient
    // multdiv_count_q-th bit is set to 1.
    is_greater_equal = (b1(accum_window_q, 31) == b1(op_b_shift_q, 31)) ?
      ~b1(res_adder_h, 31) : b1(accum_window_q, 31);

    one_shift      = cat( b32(0b0), b1(0b1) ) << multdiv_count_q;

    next_remainder = is_greater_equal ? b32(res_adder_h)         : b32(accum_window_q);
    next_quotient  = is_greater_equal ? op_a_shift_q | one_shift : op_a_shift_q;

    div_change_sign = (sign_a ^ sign_b) & ~div_by_zero_q;
    rem_change_sign = sign_a;
  }

  void tock2(logic<1>  mult_en_i,
    logic<1>  div_en_i,
    logic<1>  mult_sel_i,
    logic<1>  div_sel_i,
    ibex_pkg::md_op_e   operator_i,
    logic<2>  signed_mode_i,
    logic<32> op_a_i,
    logic<32> op_b_i,
    logic<34> alu_adder_ext_i,
    logic<32> alu_adder_i,
    logic<1>  equal_to_zero_i,
    logic<1>  data_ind_timing_i,
    logic<34> imd_val_q_i[2],
    logic<1>  multdiv_ready_id_i) {
    using namespace ibex_pkg;
    multdiv_count_d  = multdiv_count_q;
    accum_window_d   = accum_window_q;
    op_b_shift_d     = op_b_shift_q;
    op_a_shift_d     = op_a_shift_q;
    op_numerator_d   = op_numerator_q;
    md_state_d       = md_state_q;
    multdiv_hold     = b1(0b0);
    div_by_zero_d    = div_by_zero_q;
    if (mult_sel_i || div_sel_i) {
      switch (md_state_q) {
        case md_fsm_e::MD_IDLE : {
          switch (operator_i) {
            case md_op_e::MD_OP_MULL : {
              op_a_shift_d   = op_a_ext << 1;
              accum_window_d = cat(~(op_a_ext[32] & op_b_i[0]),
                                   b32(op_a_ext) & dup<32>(op_b_i[0]));
              op_b_shift_d   = op_b_ext >> 1;
              // Proceed with multiplication by 0/1 in data-independent time mode
              md_state_d     = (!data_ind_timing_i && ((op_b_ext >> 1) == 0)) ? md_fsm_e::MD_LAST : md_fsm_e::MD_COMP;
              break;
            }
            case md_op_e::MD_OP_MULH: {
              op_a_shift_d   = op_a_ext;
              accum_window_d = cat( b1(0b1), ~(op_a_ext[32] & op_b_i[0]),
                                   b31(op_a_ext, 1) & dup<31>(op_b_i[0])  );
              op_b_shift_d   = op_b_ext >> 1;
              md_state_d     = md_fsm_e::MD_COMP;
              break;
            }
            case md_op_e::MD_OP_DIV : {
              // Check if the denominator is 0
              // quotient for division by 0 is specified to be -1
              // Note with data-independent time option, the full divide operation will proceed as
              // normal and will naturally return -1
              accum_window_d = dup<33>(b1(0b1));
              md_state_d     = (!data_ind_timing_i && equal_to_zero_i) ? md_fsm_e::MD_FINISH : md_fsm_e::MD_ABS_A;
              // Record that this is a div by zero to stop the sign change at the end of the
              // division (in data_ind_timing mode).
              div_by_zero_d  = equal_to_zero_i;
              break;
            }
            case md_op_e::MD_OP_REM : {
              // Check if the denominator is 0
              // remainder for division by 0 is specified to be the numerator (operand a)
              // Note with data-independent time option, the full divide operation will proceed as
              // normal and will naturally return operand a
              accum_window_d = op_a_ext;
              md_state_d     = (!data_ind_timing_i && equal_to_zero_i) ? md_fsm_e::MD_FINISH : md_fsm_e::MD_ABS_A;
              break;
            }
            default: break;
          }
          multdiv_count_d   = b5(31);
          break;
        }

        case md_fsm_e::MD_ABS_A: {
          // quotient
          op_a_shift_d = 0;
          // A abs value
          op_numerator_d = sign_a ? alu_adder_i : op_a_i;
          md_state_d     = md_fsm_e::MD_ABS_B;
          break;
        }

        case md_fsm_e::MD_ABS_B: {
          // remainder
          accum_window_d = cat(b32(0x0), b1(op_numerator_q, 31));
          // B abs value
          op_b_shift_d   = sign_b ? cat(b1(0b0), alu_adder_i) : cat(b1(0b0), op_b_i);
          md_state_d     = md_fsm_e::MD_COMP;
          break;
        }

        case md_fsm_e::MD_COMP: {
          multdiv_count_d = multdiv_count_q - b5(0x1);
          switch (operator_i) {
            case md_op_e::MD_OP_MULL: {
              accum_window_d = res_adder_l;
              op_a_shift_d   = op_a_shift_q << 1;
              op_b_shift_d   = op_b_shift_q >> 1;
              // Multiplication is complete once op_b is zero, unless in data_ind_timing mode where
              // the maximum possible shift-add operations will be completed regardless of op_b
              md_state_d     = ((!data_ind_timing_i && (op_b_shift_d == 0)) ||
                                (multdiv_count_q == b5(1))) ? md_fsm_e::MD_LAST : md_fsm_e::MD_COMP;
              break;
            }
            case md_op_e::MD_OP_MULH: {
              accum_window_d = res_adder_h;
              op_a_shift_d   = op_a_shift_q;
              op_b_shift_d   = op_b_shift_q >> 1;
              md_state_d     = (multdiv_count_q == b5(1)) ? md_fsm_e::MD_LAST : md_fsm_e::MD_COMP;
              break;
            }
            case md_op_e::MD_OP_DIV:
            case md_op_e::MD_OP_REM: {
              accum_window_d = cat(b32(next_remainder), op_numerator_q[multdiv_count_d]);
              op_a_shift_d   = next_quotient;
              md_state_d     = (multdiv_count_q == b5(1)) ? md_fsm_e::MD_LAST : md_fsm_e::MD_COMP;
              break;
            }
            default: break;
          }
          break;
        }

        case md_fsm_e::MD_LAST: {
          switch (operator_i) {
            case md_op_e::MD_OP_MULL: {
              accum_window_d = res_adder_l;

              // Note no state transition will occur if multdiv_hold is set
              md_state_d   = md_fsm_e::MD_IDLE;
              multdiv_hold = ~multdiv_ready_id_i;
              break;
            }
            case md_op_e::MD_OP_MULH: {
              accum_window_d = res_adder_l;
              md_state_d     = md_fsm_e::MD_IDLE;

              // Note no state transition will occur if multdiv_hold is set
              md_state_d   = md_fsm_e::MD_IDLE;
              multdiv_hold = ~multdiv_ready_id_i;
              break;
            }
            case md_op_e::MD_OP_DIV: {
              // this time we save the quotient in accum_window_q since we do not need anymore the
              // remainder
              accum_window_d = next_quotient;
              md_state_d     = md_fsm_e::MD_CHANGE_SIGN;
              break;
            }
            case md_op_e::MD_OP_REM: {
              // this time we do not save the quotient anymore since we need only the remainder
              accum_window_d = cat(b1(0b0), b32(next_remainder));
              md_state_d     = md_fsm_e::MD_CHANGE_SIGN;
              break;
            }
            default: break;
          }
          break;
        }

        case md_fsm_e::MD_CHANGE_SIGN: {
          md_state_d = md_fsm_e::MD_FINISH;
          switch (operator_i) {
            case md_op_e::MD_OP_DIV:
              accum_window_d = div_change_sign ? cat(b1(0b0), alu_adder_i) : accum_window_q;
              break;
            case md_op_e::MD_OP_REM:
              accum_window_d = rem_change_sign ? cat(b1(0b0), alu_adder_i) : accum_window_q;
              break;
            default: break;
          }
          break;
        }

        case md_fsm_e::MD_FINISH : {
          // Note no state transition will occur if multdiv_hold is set
          md_state_d   = md_fsm_e::MD_IDLE;
          multdiv_hold = ~multdiv_ready_id_i;
          break;
        }

        default: {
          md_state_d = md_fsm_e::MD_IDLE;
          break;
        }
      } // md_state_q
    } // (mult_sel_i || div_sel_i)
  }

  //////////////////////////////////////////
  // Mutliplier / Divider state registers //
  //////////////////////////////////////////

  void tock5(logic<1>  mult_en_i, logic<1>  div_en_i) {
    multdiv_en = (mult_en_i | div_en_i) & ~multdiv_hold;
  }

  void tick(bool rst_n) {
    if (!rst_n) {
      multdiv_count_q  = b5(0x0);
      op_b_shift_q     = b33(0x0);
      op_a_shift_q     = b33(0x0);
      md_state_q       = md_fsm_e::MD_IDLE;
      div_by_zero_q    = b1(0b0);
    } else if (multdiv_en) {
      multdiv_count_q  = multdiv_count_d;
      op_b_shift_q     = op_b_shift_d;
      op_a_shift_q     = op_a_shift_d;
      md_state_q       = md_state_d;
      div_by_zero_q    = div_by_zero_d;
    }
  }

  /////////////
  // Outputs //
  /////////////

  void tock3(bool rst_n, ibex_pkg::md_op_e operator_i, logic<1> div_en_i) {
    using namespace ibex_pkg;
    valid_o = (md_state_q == md_fsm_e::MD_FINISH) |
              ((md_state_q == md_fsm_e::MD_LAST) &
              ((operator_i == md_op_e::MD_OP_MULL) |
               (operator_i == md_op_e::MD_OP_MULH)));

    multdiv_result_o = div_en_i ? b32(accum_window_q) : b32(res_adder_l);
  }

/*
  ////////////////
  // Assertions //
  ////////////////

  // State must be valid.
  `ASSERT(IbexMultDivStateValid, md_state_q inside {
      MD_IDLE, MD_ABS_A, MD_ABS_B, MD_COMP, MD_LAST, MD_CHANGE_SIGN, MD_FINISH
      }, clk_i, !rst_ni)

`ifdef FORMAL
  `ifdef YOSYS
    `include "formal_tb_frag.svh"
  `endif
`endif
 */
};// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// N:1 fixed priority arbiter module (index 0 has highest prio)
//
// Verilog parameter
//   N:           Number of request ports
//   DW:          Data width
//   DataPort:    Set to 1 to enable the data port. Otherwise that port will be ignored.
//
// See also: prim_arbiter_ppc, prim_arbiter_tree

#pragma once
#include "metron_tools.h"

template<
  int N = 8,
  int DW = 32,

  // Configurations
  // EnDataPort: {0, 1}, if 0, input data will be ignored
  int EnDataPort = 1,

  // Derived parameters
  int IdxW = clog2(N)
>
struct prim_arbiter_fixed {

  logic<N>    gnt_o;
  logic<IdxW> idx_o;

  logic<1>    valid_o;
  logic<DW>   data_o;


  prim_arbiter_fixed() {
  }

  void tick(bool rst_n, logic<N> req_i, logic<DW> data_i[N], logic<1> ready_i) {
  }

  // align to powers of 2 for simplicity
  // a full binary tree with N levels has 2**N + 2**N-1 nodes
  logic<pow2(IdxW + 1) - 1> req_tree;
  logic<pow2(IdxW + 1) - 1> gnt_tree;
  logic<pow2(IdxW + 1) - 1> idx_tree[IdxW];
  logic<pow2(IdxW + 1) - 1> data_tree[DW];

  void tock(bool rst_n, logic<N> req_i, logic<DW> data_i[N], logic<1> ready_i) {
    /*
    for (int level = 0; level < IdxW + 1; level++) {
      //
      // level+1   C0   C1   <- "Base1" points to the first node on "level+1",
      //            \  /         these nodes are the children of the nodes one level below
      // level       Pa      <- "Base0", points to the first node on "level",
      //                         these nodes are the parents of the nodes one level above
      //
      // hence we have the following indices for the Pa, C0, C1 nodes:
      // Pa = 2**level     - 1 + offset       = Base0 + offset
      // C0 = 2**(level+1) - 1 + 2*offset     = Base1 + 2*offset
      // C1 = 2**(level+1) - 1 + 2*offset + 1 = Base1 + 2*offset + 1
      //

      static const int Base0 = pow2(level) - 1;
      static const int Base1 = pow2(level + 1) - 1;

      for (int offset = 0; offset < pow2(level); offset++) {
      }
    }

    // the results can be found at the tree root
    if (EnDataPort) {
      data_o = data_tree[0];
    } else {
      logic<DW> unused_data;
      unused_data = data_tree[0];
      data_o = 1;
    }

    idx_o       = idx_tree[0];
    valid_o     = req_tree[0];

    // this propagates a grant back to the input
    gnt_tree[0] = valid_o & ready_i;
    */
  }

};
// Copyright lowRISC contributors.
// Copyright 2017 ETH Zurich and University of Bologna, see also CREDITS.md.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#pragma once
#include "metron_tools.h"

/**
 * Package with constants used by Ibex
 */
namespace ibex_pkg {

  ////////////////
  // IO Structs //
  ////////////////

  struct crash_dump_t {
    logic<32> current_pc;
    logic<32> next_pc;
    logic<32> last_data_addr;
    logic<32> exception_addr;
  };

  struct core2rf_t {
    logic<1> dummy_instr_id;
    logic<5> raddr_a;
    logic<5> waddr_a;
    logic<1> we_a;
    logic<5> raddr_b;
  };

  /////////////////////
  // Parameter Enums //
  /////////////////////

  enum class regfile_e : int {
    RegFileFF    = 0,
    RegFileFPGA  = 1,
    RegFileLatch = 2
  };

  enum class rv32m_e : int {
    RV32MNone        = 0,
    RV32MSlow        = 1,
    RV32MFast        = 2,
    RV32MSingleCycle = 3
  };

  enum class rv32b_e : int {
    RV32BNone       = 0,
    RV32BBalanced   = 1,
    RV32BOTEarlGrey = 2,
    RV32BFull       = 3
  };

  /////////////
  // Opcodes //
  /////////////

  enum class opcode_e : logic<7>::BASE {
    OPCODE_LOAD     = 0x03,
    OPCODE_MISC_MEM = 0x0f,
    OPCODE_OP_IMM   = 0x13,
    OPCODE_AUIPC    = 0x17,
    OPCODE_STORE    = 0x23,
    OPCODE_OP       = 0x33,
    OPCODE_LUI      = 0x37,
    OPCODE_BRANCH   = 0x63,
    OPCODE_JALR     = 0x67,
    OPCODE_JAL      = 0x6f,
    OPCODE_SYSTEM   = 0x73
  };


  ////////////////////
  // ALU operations //
  ////////////////////

  enum class alu_op_e : logic<7>::BASE {
    // Arithmetics
    ALU_ADD,
    ALU_SUB,

    // Logics
    ALU_XOR,
    ALU_OR,
    ALU_AND,
    // RV32B
    ALU_XNOR,
    ALU_ORN,
    ALU_ANDN,

    // Shifts
    ALU_SRA,
    ALU_SRL,
    ALU_SLL,
    // RV32B
    ALU_SRO,
    ALU_SLO,
    ALU_ROR,
    ALU_ROL,
    ALU_GREV,
    ALU_GORC,
    ALU_SHFL,
    ALU_UNSHFL,
    ALU_XPERM_N,
    ALU_XPERM_B,
    ALU_XPERM_H,

    // Address Calculations
    // RV32B
    ALU_SH1ADD,
    ALU_SH2ADD,
    ALU_SH3ADD,

    // Comparisons
    ALU_LT,
    ALU_LTU,
    ALU_GE,
    ALU_GEU,
    ALU_EQ,
    ALU_NE,
    // RV32B
    ALU_MIN,
    ALU_MINU,
    ALU_MAX,
    ALU_MAXU,

    // Pack
    // RV32B
    ALU_PACK,
    ALU_PACKU,
    ALU_PACKH,

    // Sign-Extend
    // RV32B
    ALU_SEXTB,
    ALU_SEXTH,

    // Bitcounting
    // RV32B
    ALU_CLZ,
    ALU_CTZ,
    ALU_CPOP,

    // Set lower than
    ALU_SLT,
    ALU_SLTU,

    // Ternary Bitmanip Operations
    // RV32B
    ALU_CMOV,
    ALU_CMIX,
    ALU_FSL,
    ALU_FSR,

    // Single-Bit Operations
    // RV32B
    ALU_BSET,
    ALU_BCLR,
    ALU_BINV,
    ALU_BEXT,

    // Bit Compress / Decompress
    // RV32B
    ALU_BCOMPRESS,
    ALU_BDECOMPRESS,

    // Bit Field Place
    // RV32B
    ALU_BFP,

    // Carry-less Multiply
    // RV32B
    ALU_CLMUL,
    ALU_CLMULR,
    ALU_CLMULH,

    // Cyclic Redundancy Check
    ALU_CRC32_B,
    ALU_CRC32C_B,
    ALU_CRC32_H,
    ALU_CRC32C_H,
    ALU_CRC32_W,
    ALU_CRC32C_W
  };

  enum class md_op_e : logic<2>::BASE {
    // Multiplier/divider
    MD_OP_MULL,
    MD_OP_MULH,
    MD_OP_DIV,
    MD_OP_REM
  };


  //////////////////////////////////
  // Control and status registers //
  //////////////////////////////////

  // CSR operations
  enum class csr_op_e : logic<2>::BASE {
    CSR_OP_READ,
    CSR_OP_WRITE,
    CSR_OP_SET,
    CSR_OP_CLEAR
  };

  // Privileged mode
  enum class priv_lvl_e : logic<2>::BASE {
    PRIV_LVL_M = 0b11,
    PRIV_LVL_H = 0b10,
    PRIV_LVL_S = 0b01,
    PRIV_LVL_U = 0b00
  };

  // Constants for the dcsr.xdebugver fields
  enum class x_debug_ver_e : logic<4>::BASE {
    XDEBUGVER_NO     = 0, // no external debug support
    XDEBUGVER_STD    = 4, // external debug according to RISC-V debug spec
    XDEBUGVER_NONSTD = 15 // debug not conforming to RISC-V debug spec
  };

  //////////////
  // WB stage //
  //////////////

  // Type of instruction present in writeback stage
  enum class wb_instr_type_e : logic<2>::BASE {
    WB_INSTR_LOAD,  // Instruction is awaiting load data
    WB_INSTR_STORE, // Instruction is awaiting store response
    WB_INSTR_OTHER  // Instruction doesn't fit into above categories
  };

  //////////////
  // ID stage //
  //////////////

  // Operand a selection
  enum class op_a_sel_e : logic<2>::BASE {
    OP_A_REG_A,
    OP_A_FWD,
    OP_A_CURRPC,
    OP_A_IMM
  };

  // Immediate a selection
  enum class imm_a_sel_e : logic<1>::BASE {
    IMM_A_Z,
    IMM_A_ZERO
  };

  // Operand b selection
  enum class op_b_sel_e : logic<1>::BASE  {
    OP_B_REG_B,
    OP_B_IMM
  };

  // Immediate b selection
  enum class imm_b_sel_e : logic<3>::BASE {
    IMM_B_I,
    IMM_B_S,
    IMM_B_B,
    IMM_B_U,
    IMM_B_J,
    IMM_B_INCR_PC,
    IMM_B_INCR_ADDR
  };

  // Regfile write data selection
  enum class rf_wd_sel_e : logic<1>::BASE  {
    RF_WD_EX,
    RF_WD_CSR
  };

  //////////////
  // IF stage //
  //////////////

  // PC mux selection
  enum class pc_sel_e : logic<3>::BASE {
    PC_BOOT,
    PC_JUMP,
    PC_EXC,
    PC_ERET,
    PC_DRET,
    PC_BP
  };

  // Exception PC mux selection
  enum class exc_pc_sel_e : logic<2>::BASE {
    EXC_PC_EXC,
    EXC_PC_IRQ,
    EXC_PC_DBD,
    EXC_PC_DBG_EXC // Exception while in debug mode
  };

  // Interrupt requests
  struct irqs_t {
    logic<1>  irq_software;
    logic<1>  irq_timer;
    logic<1>  irq_external;
    logic<15> irq_fast; // 15 fast interrupts,
                          // one interrupt is reserved for NMI (not visible through mip/mie)
  };

  // Exception cause
  enum class exc_cause_e : logic<6>::BASE {
    EXC_CAUSE_IRQ_SOFTWARE_M     = 0b100011,
    EXC_CAUSE_IRQ_TIMER_M        = 0b100111,
    EXC_CAUSE_IRQ_EXTERNAL_M     = 0b101011,
    // EXC_CAUSE_IRQ_FAST_0      = 0b110000,
    // EXC_CAUSE_IRQ_FAST_14     = 0b111110,
    EXC_CAUSE_IRQ_NM             = 0b111111, // == EXC_CAUSE_IRQ_FAST_15
    EXC_CAUSE_INSN_ADDR_MISA     = 0b000000,
    EXC_CAUSE_INSTR_ACCESS_FAULT = 0b000001,
    EXC_CAUSE_ILLEGAL_INSN       = 0b000010,
    EXC_CAUSE_BREAKPOINT         = 0b000011,
    EXC_CAUSE_LOAD_ACCESS_FAULT  = 0b000101,
    EXC_CAUSE_STORE_ACCESS_FAULT = 0b000111,
    EXC_CAUSE_ECALL_UMODE        = 0b001000,
    EXC_CAUSE_ECALL_MMODE        = 0b001011
  };

  // Debug cause
  enum class dbg_cause_e : logic<3>::BASE {
    DBG_CAUSE_NONE    = 0x0,
    DBG_CAUSE_EBREAK  = 0x1,
    DBG_CAUSE_TRIGGER = 0x2,
    DBG_CAUSE_HALTREQ = 0x3,
    DBG_CAUSE_STEP    = 0x4
  };

  // ICache constants
  static const unsigned int ADDR_W           = 32; 
  static const unsigned int BUS_SIZE         = 32;
  static const unsigned int BUS_BYTES        = BUS_SIZE/8;
  static const unsigned int BUS_W            = clog2(BUS_BYTES);
  static const unsigned int IC_SIZE_BYTES    = 4096;
  static const unsigned int IC_NUM_WAYS      = 2;
  static const unsigned int IC_LINE_SIZE     = 64;
  static const unsigned int IC_LINE_BYTES    = IC_LINE_SIZE/8;
  static const unsigned int IC_LINE_W        = clog2(IC_LINE_BYTES);
  static const unsigned int IC_NUM_LINES     = IC_SIZE_BYTES / IC_NUM_WAYS / IC_LINE_BYTES;
  static const unsigned int IC_LINE_BEATS    = IC_LINE_BYTES / BUS_BYTES;
  static const unsigned int IC_LINE_BEATS_W  = clog2(IC_LINE_BEATS);
  static const unsigned int IC_INDEX_W       = clog2(IC_NUM_LINES);
  static const unsigned int IC_INDEX_HI      = IC_INDEX_W + IC_LINE_W - 1;
  static const unsigned int IC_TAG_SIZE      = ADDR_W - IC_INDEX_W - IC_LINE_W + 1; // 1 valid bit
  static const unsigned int IC_OUTPUT_BEATS  = (BUS_BYTES / 2); // number of halfwords
  // ICache Scrambling Parameters
  static const unsigned int SCRAMBLE_KEY_W   = 128;
  static const unsigned int SCRAMBLE_NONCE_W = 64;

  // PMP constants
  static const unsigned int PMP_MAX_REGIONS      = 16;
  static const unsigned int PMP_CFG_W            = 8;

  // PMP acces type
  static const unsigned int PMP_I  = 0;
  static const unsigned int PMP_I2 = 1;
  static const unsigned int PMP_D  = 2;

  enum class pmp_req_e : logic<2>::BASE {
    PMP_ACC_EXEC    = 0b00,
    PMP_ACC_WRITE   = 0b01,
    PMP_ACC_READ    = 0b10
  };

  // PMP cfg structures
  enum class pmp_cfg_mode_e : logic<2>::BASE {
    PMP_MODE_OFF   = 0b00,
    PMP_MODE_TOR   = 0b01,
    PMP_MODE_NA4   = 0b10,
    PMP_MODE_NAPOT = 0b11
  };

  struct pmp_cfg_t {
    logic<1>       lock;
    pmp_cfg_mode_e mode;
    logic<1>       exec;
    logic<1>       write;
    logic<1>       read;
  };

  // Machine Security Configuration (ePMP)
  struct pmp_mseccfg_t {
    logic<1> rlb;  // Rule Locking Bypass
    logic<1> mmwp; // Machine Mode Whitelist Policy
    logic<1> mml;  // Machine Mode Lockdown
  };

  // CSRs
  enum class csr_num_e : logic<12>::BASE {
    // Machine information
    CSR_MVENDORID = 0xF11,
    CSR_MARCHID   = 0xF12,
    CSR_MIMPID    = 0xF13,
    CSR_MHARTID   = 0xF14,

    // Machine trap setup
    CSR_MSTATUS   = 0x300,
    CSR_MISA      = 0x301,
    CSR_MIE       = 0x304,
    CSR_MTVEC     = 0x305,
    CSR_MCOUNTEREN= 0x306,

    // Machine trap handling
    CSR_MSCRATCH  = 0x340,
    CSR_MEPC      = 0x341,
    CSR_MCAUSE    = 0x342,
    CSR_MTVAL     = 0x343,
    CSR_MIP       = 0x344,

    // Physical memory protection
    CSR_PMPCFG0   = 0x3A0,
    CSR_PMPCFG1   = 0x3A1,
    CSR_PMPCFG2   = 0x3A2,
    CSR_PMPCFG3   = 0x3A3,
    CSR_PMPADDR0  = 0x3B0,
    CSR_PMPADDR1  = 0x3B1,
    CSR_PMPADDR2  = 0x3B2,
    CSR_PMPADDR3  = 0x3B3,
    CSR_PMPADDR4  = 0x3B4,
    CSR_PMPADDR5  = 0x3B5,
    CSR_PMPADDR6  = 0x3B6,
    CSR_PMPADDR7  = 0x3B7,
    CSR_PMPADDR8  = 0x3B8,
    CSR_PMPADDR9  = 0x3B9,
    CSR_PMPADDR10 = 0x3BA,
    CSR_PMPADDR11 = 0x3BB,
    CSR_PMPADDR12 = 0x3BC,
    CSR_PMPADDR13 = 0x3BD,
    CSR_PMPADDR14 = 0x3BE,
    CSR_PMPADDR15 = 0x3BF,

    // ePMP control
    CSR_MSECCFG   = 0x747,
    CSR_MSECCFGH  = 0x757,

    // Debug trigger
    CSR_TSELECT   = 0x7A0,
    CSR_TDATA1    = 0x7A1,
    CSR_TDATA2    = 0x7A2,
    CSR_TDATA3    = 0x7A3,
    CSR_MCONTEXT  = 0x7A8,
    CSR_SCONTEXT  = 0x7AA,

    // Debug/trace
    CSR_DCSR      = 0x7b0,
    CSR_DPC       = 0x7b1,

    // Debug
    CSR_DSCRATCH0 = 0x7b2, // optional
    CSR_DSCRATCH1 = 0x7b3, // optional

    // Machine Counter/Timers
    CSR_MCOUNTINHIBIT  = 0x320,
    CSR_MHPMEVENT3     = 0x323,
    CSR_MHPMEVENT4     = 0x324,
    CSR_MHPMEVENT5     = 0x325,
    CSR_MHPMEVENT6     = 0x326,
    CSR_MHPMEVENT7     = 0x327,
    CSR_MHPMEVENT8     = 0x328,
    CSR_MHPMEVENT9     = 0x329,
    CSR_MHPMEVENT10    = 0x32A,
    CSR_MHPMEVENT11    = 0x32B,
    CSR_MHPMEVENT12    = 0x32C,
    CSR_MHPMEVENT13    = 0x32D,
    CSR_MHPMEVENT14    = 0x32E,
    CSR_MHPMEVENT15    = 0x32F,
    CSR_MHPMEVENT16    = 0x330,
    CSR_MHPMEVENT17    = 0x331,
    CSR_MHPMEVENT18    = 0x332,
    CSR_MHPMEVENT19    = 0x333,
    CSR_MHPMEVENT20    = 0x334,
    CSR_MHPMEVENT21    = 0x335,
    CSR_MHPMEVENT22    = 0x336,
    CSR_MHPMEVENT23    = 0x337,
    CSR_MHPMEVENT24    = 0x338,
    CSR_MHPMEVENT25    = 0x339,
    CSR_MHPMEVENT26    = 0x33A,
    CSR_MHPMEVENT27    = 0x33B,
    CSR_MHPMEVENT28    = 0x33C,
    CSR_MHPMEVENT29    = 0x33D,
    CSR_MHPMEVENT30    = 0x33E,
    CSR_MHPMEVENT31    = 0x33F,
    CSR_MCYCLE         = 0xB00,
    CSR_MINSTRET       = 0xB02,
    CSR_MHPMCOUNTER3   = 0xB03,
    CSR_MHPMCOUNTER4   = 0xB04,
    CSR_MHPMCOUNTER5   = 0xB05,
    CSR_MHPMCOUNTER6   = 0xB06,
    CSR_MHPMCOUNTER7   = 0xB07,
    CSR_MHPMCOUNTER8   = 0xB08,
    CSR_MHPMCOUNTER9   = 0xB09,
    CSR_MHPMCOUNTER10  = 0xB0A,
    CSR_MHPMCOUNTER11  = 0xB0B,
    CSR_MHPMCOUNTER12  = 0xB0C,
    CSR_MHPMCOUNTER13  = 0xB0D,
    CSR_MHPMCOUNTER14  = 0xB0E,
    CSR_MHPMCOUNTER15  = 0xB0F,
    CSR_MHPMCOUNTER16  = 0xB10,
    CSR_MHPMCOUNTER17  = 0xB11,
    CSR_MHPMCOUNTER18  = 0xB12,
    CSR_MHPMCOUNTER19  = 0xB13,
    CSR_MHPMCOUNTER20  = 0xB14,
    CSR_MHPMCOUNTER21  = 0xB15,
    CSR_MHPMCOUNTER22  = 0xB16,
    CSR_MHPMCOUNTER23  = 0xB17,
    CSR_MHPMCOUNTER24  = 0xB18,
    CSR_MHPMCOUNTER25  = 0xB19,
    CSR_MHPMCOUNTER26  = 0xB1A,
    CSR_MHPMCOUNTER27  = 0xB1B,
    CSR_MHPMCOUNTER28  = 0xB1C,
    CSR_MHPMCOUNTER29  = 0xB1D,
    CSR_MHPMCOUNTER30  = 0xB1E,
    CSR_MHPMCOUNTER31  = 0xB1F,
    CSR_MCYCLEH        = 0xB80,
    CSR_MINSTRETH      = 0xB82,
    CSR_MHPMCOUNTER3H  = 0xB83,
    CSR_MHPMCOUNTER4H  = 0xB84,
    CSR_MHPMCOUNTER5H  = 0xB85,
    CSR_MHPMCOUNTER6H  = 0xB86,
    CSR_MHPMCOUNTER7H  = 0xB87,
    CSR_MHPMCOUNTER8H  = 0xB88,
    CSR_MHPMCOUNTER9H  = 0xB89,
    CSR_MHPMCOUNTER10H = 0xB8A,
    CSR_MHPMCOUNTER11H = 0xB8B,
    CSR_MHPMCOUNTER12H = 0xB8C,
    CSR_MHPMCOUNTER13H = 0xB8D,
    CSR_MHPMCOUNTER14H = 0xB8E,
    CSR_MHPMCOUNTER15H = 0xB8F,
    CSR_MHPMCOUNTER16H = 0xB90,
    CSR_MHPMCOUNTER17H = 0xB91,
    CSR_MHPMCOUNTER18H = 0xB92,
    CSR_MHPMCOUNTER19H = 0xB93,
    CSR_MHPMCOUNTER20H = 0xB94,
    CSR_MHPMCOUNTER21H = 0xB95,
    CSR_MHPMCOUNTER22H = 0xB96,
    CSR_MHPMCOUNTER23H = 0xB97,
    CSR_MHPMCOUNTER24H = 0xB98,
    CSR_MHPMCOUNTER25H = 0xB99,
    CSR_MHPMCOUNTER26H = 0xB9A,
    CSR_MHPMCOUNTER27H = 0xB9B,
    CSR_MHPMCOUNTER28H = 0xB9C,
    CSR_MHPMCOUNTER29H = 0xB9D,
    CSR_MHPMCOUNTER30H = 0xB9E,
    CSR_MHPMCOUNTER31H = 0xB9F,
    CSR_CPUCTRL        = 0x7C0,
    CSR_SECURESEED     = 0x7C1
  };

  // CSR pmp-related offsets
  static const logic<12> CSR_OFF_PMP_CFG  = 0x3A0; // pmp_cfg  @ 12'h3a0 - 12'h3a3
  static const logic<12> CSR_OFF_PMP_ADDR = 0x3B0; // pmp_addr @ 12'h3b0 - 12'h3bf

  // CSR status bits
  static const unsigned int CSR_MSTATUS_MIE_BIT      = 3;
  static const unsigned int CSR_MSTATUS_MPIE_BIT     = 7;
  static const unsigned int CSR_MSTATUS_MPP_BIT_LOW  = 11;
  static const unsigned int CSR_MSTATUS_MPP_BIT_HIGH = 12;
  static const unsigned int CSR_MSTATUS_MPRV_BIT     = 17;
  static const unsigned int CSR_MSTATUS_TW_BIT       = 21;

  // CSR machine ISA
  static const logic<2> CSR_MISA_MXL = b2(1); // M-XLEN: XLEN in M-Mode for RV32

  // CSR interrupt pending/enable bits
  static const unsigned int CSR_MSIX_BIT      = 3;
  static const unsigned int CSR_MTIX_BIT      = 7;
  static const unsigned int CSR_MEIX_BIT      = 11;
  static const unsigned int CSR_MFIX_BIT_LOW  = 16;
  static const unsigned int CSR_MFIX_BIT_HIGH = 30;

  // CSR Machine Security Configuration bits
  static const unsigned int CSR_MSECCFG_MML_BIT  = 0;
  static const unsigned int CSR_MSECCFG_MMWP_BIT = 1;
  static const unsigned int CSR_MSECCFG_RLB_BIT  = 2;

  // Vendor ID
  // No JEDEC ID has been allocated to lowRISC so the value is 0 to indicate the field is not
  // implemented
  static const logic<32> CSR_MVENDORID_VALUE  = b32(0b0);

  // Architecture ID
  // Top bit is unset to indicate an open source project. The lower bits are an ID allocated by the
  // RISC-V Foundation. Note this is allocated specifically to Ibex, should significant changes be
  // made a different architecture ID should be supplied.
  static const logic<32> CSR_MARCHID_VALUE = b32(22);

  // Implementation ID
  // 0 indicates this field is not implemeted. Ibex implementors may wish to indicate an RTL/netlist
  // version here using their own unique encoding (e.g. 32 bits of the git hash of the implemented
  // commit).
  static const logic<32> CSR_MIMPID_VALUE = b32(0b0);

  // These LFSR parameters have been generated with
  // $ opentitan/util/design/gen-lfsr-seed.py --width 32 --seed 2480124384 --prefix ""
  static const int LfsrWidth = 32;
  typedef logic<LfsrWidth> lfsr_seed_t;
  typedef logic<LfsrWidth> lfsr_perm_t[clog2(LfsrWidth)]; 
  static const lfsr_seed_t RndCnstLfsrSeedDefault = b32(0xac533bf4);
  static const lfsr_perm_t RndCnstLfsrPermDefault = { b32(0x78a8daed), b32(0xc04fa438), b32(0x2e958152), b32(0x467fd1b1), b32(0x1e35ecba) };

  // we don't support 128-bit logic<>s in Metron yet
  //parameter logic [SCRAMBLE_KEY_W-1:0]   RndCnstIbexKeyDefault = 128'h14e8cecae3040d5e12286bb3cc113298;
  //parameter logic [SCRAMBLE_NONCE_W-1:0] RndCnstIbexNonceDefault = 64'hf79780bc735f3843;
}// Copyright lowRISC contributors.
// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#pragma once
#include "metron_tools.h"
#include "ibex_pkg.h"

/**
 * Arithmetic logic unit
 */
template<ibex_pkg::rv32b_e RV32B> // scope getting cut off enum
class ibex_alu {
public:

private:
  logic<32> operand_a_rev;
  logic<33> operand_b_neg;
public:

  void tock_rev(logic<32> operand_a_i) {
    for (int k = 0; k < 32; k++) {
      operand_a_rev[k] = operand_a_i[31-k];
    }
  }

  ///////////
  // Adder //
  ///////////

private:
  logic<1>  adder_op_a_shift1;
  logic<1>  adder_op_a_shift2;
  logic<1>  adder_op_a_shift3;
  logic<1>  adder_op_b_negate;
  //logic<33> adder_in_a, adder_in_b;
  //logic<32> adder_result;
public:

  void tock1(ibex_pkg::alu_op_e operator_i) {
    using namespace ibex_pkg;

    adder_op_a_shift1 = 0;
    adder_op_a_shift2 = 0;
    adder_op_a_shift3 = 0;
    adder_op_b_negate = 0;

    /*#unique#*/ switch(operator_i) {
      // Adder OPs
      case alu_op_e::ALU_SUB:
        adder_op_b_negate = 1;
        break;

      // Comparator OPs
      case alu_op_e::ALU_EQ:
      case alu_op_e::ALU_NE:
      case alu_op_e::ALU_GE:
      case alu_op_e::ALU_GEU:
      case alu_op_e::ALU_LT:
      case alu_op_e::ALU_LTU:
      case alu_op_e::ALU_SLT:
      case alu_op_e::ALU_SLTU:
        adder_op_b_negate = 1;
        break;

      default:
        break;
    }
  }


  void tick() {
    operand_b_neg = 0;
  }


};
// Copyright lowRISC contributors.
// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

/**
 * Compressed instruction decoder
 *
 * Decodes RISC-V compressed instructions into their RV32 equivalent.
 * This module is fully combinatorial, clock and reset are used for
 * assertions only.
 */

#pragma once
#include "metron_tools.h"
#include "ibex_pkg.h"

struct ibex_compressed_decoder {
  logic<1>  is_compressed_o;
  logic<1>  illegal_instr_o;
  logic<32> instr_o;

  // valid_i indicates if instr_i is valid and is used for assertions only.
  // The following signal is used to avoid possible lint errors.
  logic<1> unused_valid;
  void tock2(bool rst_n, logic<1> valid_i) {
    unused_valid = valid_i;
  }
  
  ////////////////////////
  // Compressed decoder //
  ////////////////////////

  void tock(bool rst_n, logic<1> valid_i, logic<32> instr_i) {
    using namespace ibex_pkg;

    // By default, forward incoming instruction, mark it as legal.
    instr_o = instr_i;
    illegal_instr_o = b1(0b0);

    // Check if incoming instruction is compressed.
    switch (b2(instr_i)) {
      // C0
      case 0b00: {
        switch (b3(instr_i, 13)) {
          case 0b000: {
            // c.addi4spn -> addi rd', x2, imm
            instr_o = cat(b2(0b0), b4(instr_i, 7), b2(instr_i, 11), instr_i[5],
                       instr_i[6], b2(0b00), b5(0x02), b3(0b000), b2(0b01), b3(instr_i, 2), b7(opcode_e::OPCODE_OP_IMM));
            if (b8(instr_i, 5) == b8(0b0))  illegal_instr_o = b1(0b1);
            break;
          }

          case 0b010: {
            // c.lw -> lw rd', imm(rs1')
            instr_o = cat(b5(0b0), instr_i[5], b3(instr_i, 10), instr_i[6],
                       b2(0b00), b2(0b01), b3(instr_i, 7), b3(0b010), b2(0b01), b3(instr_i, 2), b7(opcode_e::OPCODE_LOAD));
            break;
          }

          case 0b110: {
            // c.sw -> sw rs2', imm(rs1')
            instr_o = cat(b5(0b0), instr_i[5], instr_i[12], b2(0b01), b3(instr_i, 2),
                       b2(0b01), b3(instr_i, 7), b3(0b010), b2(instr_i, 10), instr_i[6],
                       b2(0b00), b7(opcode_e::OPCODE_STORE));
            break;
          }
          
          case 0b001:
          case 0b011:
          case 0b100:
          case 0b101:
          case 0b111: {
            illegal_instr_o = b1(0b1);
          }

          default: {
            illegal_instr_o = b1(0b1);
          }
        }
        break;
      }

      // C1
      //
      // Register address checks for RV32E are performed in the regular instruction decoder.
      // If this check fails, an illegal instruction exception is triggered and the controller
      // writes the actual faulting instruction to mtval.
      case 0b01: {
        switch (b3(instr_i, 13)) {
          case 0b000: {
            // c.addi -> addi rd, rd, nzimm
            // c.nop
            instr_o = cat(dup<6>(instr_i[12]), instr_i[12], b5(instr_i, 2),
                       b5(instr_i, 7), b3(0b0), b5(instr_i, 7), b7(opcode_e::OPCODE_OP_IMM));
            break;
          }

          case 0b001: case 0b101: {
            // 001: c.jal -> jal x1, imm
            // 101: c.j   -> jal x0, imm
            instr_o = cat(instr_i[12], instr_i[8], b2(instr_i, 9), instr_i[6],
                          instr_i[7], instr_i[2], instr_i[11], b3(instr_i, 3),
                          dup<9>(instr_i[12]), b4(0b0), ~instr_i[15], b7(opcode_e::OPCODE_JAL));
            break;
          }

          case 0b010: {
            // c.li -> addi rd, x0, nzimm
            // (c.li hints are translated into an addi hint)
            instr_o = cat(dup<6>(instr_i[12]), instr_i[12], b5(instr_i, 2), b5(0b0),
                       b3(0b0), b5(instr_i, 7), b7(opcode_e::OPCODE_OP_IMM));
            break;
          }

          case 0b011: {
            // c.lui -> lui rd, imm
            // (c.lui hints are translated into a lui hint)
            instr_o = cat(dup<15>(instr_i[12]), b5(instr_i, 2), b5(instr_i, 7), b7(opcode_e::OPCODE_LUI));

            if (b5(instr_i, 7) == b5(0x02)) {
              // c.addi16sp -> addi x2, x2, nzimm
              instr_o = cat(dup<3>(instr_i[12]), b2(instr_i, 3), instr_i[5], instr_i[2],
                         instr_i[6], b4(0b0), b5(0x02), b3(0b000), b5(0x02), b7(opcode_e::OPCODE_OP_IMM));
            }

            if (cat(instr_i[12], b5(instr_i, 2)) == b6(0b0)) illegal_instr_o = b1(0b1);
            break;
          }

          case 0b100: {
            switch (b2(instr_i, 10)) {
              case 0b00:
              case 0b01: {
                // 00: c.srli -> srli rd, rd, shamt
                // 01: c.srai -> srai rd, rd, shamt
                // (c.srli/c.srai hints are translated into a srli/srai hint)
                instr_o = cat(b1(0b0), instr_i[10], b5(0b0), b5(instr_i, 2), b2(0b01), b3(instr_i, 7),
                           b3(0b101), b2(0b01), b3(instr_i, 7), b7(opcode_e::OPCODE_OP_IMM));
                if (instr_i[12] == 0b1)  illegal_instr_o = b1(0b1);
                break;
              }

              case 0b10: {
                // c.andi -> andi rd, rd, imm
                instr_o = cat(dup<6>(instr_i[12]), instr_i[12], b5(instr_i, 2), b2(0b01), b3(instr_i, 7),
                           b3(0b111), b2(0b01), b3(instr_i, 7), b7(opcode_e::OPCODE_OP_IMM));
                break;
              }

              case 0b11: {
                switch (cat(instr_i[12], b2(instr_i, 5))) {
                  case 0b000: {
                    // c.sub -> sub rd', rd', rs2'
                    instr_o = cat(b2(0b01), b5(0b0), b2(0b01), b3(instr_i, 2), b2(0b01), b3(instr_i, 7),
                               b3(0b000), b2(0b01), b3(instr_i, 7), b7(opcode_e::OPCODE_OP));
                    break;
                  }

                  case 0b001: {
                    // c.xor -> xor rd', rd', rs2'
                    instr_o = cat(b7(0b0), b2(0b01), b3(instr_i, 2), b2(0b01), b3(instr_i, 7), b3(0b100),
                               b2(0b01), b3(instr_i, 7), b7(opcode_e::OPCODE_OP));
                    break;
                  }

                  case 0b010: {
                    // c.or  -> or  rd', rd', rs2'
                    instr_o = cat(b7(0b0), b2(0b01), b3(instr_i, 2), b2(0b01), b3(instr_i, 7), b3(0b110),
                               b2(0b01), b3(instr_i, 7), b7(opcode_e::OPCODE_OP));
                    break;
                  }

                  case 0b011: {
                    // c.and -> and rd', rd', rs2'
                    instr_o = cat(b7(0b0), b2(0b01), b3(instr_i, 2), b2(0b01), b3(instr_i, 7), b3(0b111),
                               b2(0b01), b3(instr_i, 7), b7(opcode_e::OPCODE_OP));
                    break;
                  }

                  case 0b100:
                  case 0b101:
                  case 0b110:
                  case 0b111: {
                    // 100: c.subw
                    // 101: c.addw
                    illegal_instr_o = b1(0b1);
                    break;
                  }

                  default: {
                    illegal_instr_o = b1(0b1);
                    break;
                  }
                }
                break;
              }

              default: {
                illegal_instr_o = b1(0b1);
                break;
              }
            }
            break;
          }

          case 0b110: case 0b111: {
            // 0: c.beqz -> beq rs1', x0, imm
            // 1: c.bnez -> bne rs1', x0, imm
            instr_o = cat(dup<4>(instr_i[12]), b2(instr_i, 5), instr_i[2], b5(0b0), b2(0b01),
                       b3(instr_i, 7), b2(0b00), instr_i[13], b2(instr_i, 10), b2(instr_i, 3),
                       instr_i[12], b7(opcode_e::OPCODE_BRANCH));
            break;
          }

          default: {
            illegal_instr_o = b1(0b1);
            break;
          }
        }
        break;
      }

      // C2
      //
      // Register address checks for RV32E are performed in the regular instruction decoder.
      // If this check fails, an illegal instruction exception is triggered and the controller
      // writes the actual faulting instruction to mtval.
      case 0b10: {
        switch (b3(instr_i, 13)) {
          case 0b000: {
            // c.slli -> slli rd, rd, shamt
            // (c.ssli hints are translated into a slli hint)
            instr_o = cat(b7(0b0), b5(instr_i, 2), b5(instr_i, 7), b3(0b001), b5(instr_i, 7), b7(opcode_e::OPCODE_OP_IMM));
            if (instr_i[12] == 0b1)  illegal_instr_o = b1(0b1); // reserved for custom extensions
            break;
          }

          case 0b010: {
            // c.lwsp -> lw rd, imm(x2)
            instr_o = cat(b4(0b0), b2(instr_i, 2), instr_i[12], b3(instr_i, 4), b2(0b00), b5(0x02),
                       b3(0b010), b5(instr_i, 7), b7(opcode_e::OPCODE_LOAD));
            if (b5(instr_i, 7) == b5(0b0))  illegal_instr_o = b1(0b1);
            break;
          }

          case 0b100: {
            if (instr_i[12] == 0b0) {
              if (b5(instr_i, 2) != b5(0b0)) {
                // c.mv -> add rd/rs1, x0, rs2
                // (c.mv hints are translated into an add hint)
                instr_o = cat(b7(0b0), b5(instr_i, 2), b5(0b0), b3(0b0), b5(instr_i, 7), b7(opcode_e::OPCODE_OP));
              } else {
                // c.jr -> jalr x0, rd/rs1, 0
                instr_o = cat(b12(0b0), b5(instr_i, 7), b3(0b0), b5(0b0), b7(opcode_e::OPCODE_JALR));
                if (b5(instr_i, 7) == b5(0b0)) illegal_instr_o = b1(0b1);
              }
            } else {
              if (b5(instr_i, 2) != b5(0b0)) {
                // c.add -> add rd, rd, rs2
                // (c.add hints are translated into an add hint)
                instr_o = cat(b7(0b0), b5(instr_i, 2), b5(instr_i, 7), b3(0b0), b5(instr_i, 7), b7(opcode_e::OPCODE_OP));
              } else {
                if (b5(instr_i, 7) == b5(0b0)) {
                  // c.ebreak -> ebreak
                  instr_o = b32(0x00'10'00'73);
                } else {
                  // c.jalr -> jalr x1, rs1, 0
                  instr_o = cat(b12(0b0), b5(instr_i, 7), b3(0b000), b5(0b00001), b7(opcode_e::OPCODE_JALR));
                }
              }
            }
            break;
          }

          case 0b110: {
            // c.swsp -> sw rs2, imm(x2)
            instr_o = cat(b4(0b0), b2(instr_i, 7), instr_i[12], b5(instr_i, 2), b5(0x02), b3(0b010),
                       b3(instr_i, 9), b2(0b00), b7(opcode_e::OPCODE_STORE));
            break;
          }

          case 0b001:
          case 0b011:
          case 0b101:
          case 0b111: {
            illegal_instr_o = b1(0b1);
            break;
          }

          default: {
            illegal_instr_o = b1(0b1);
            break;
          }
        }
        break;
      }

      // Incoming instruction is not compressed.
      case 0b11:; break;

      default: {
        illegal_instr_o = b1(0b1);
      }
    }
  }

  void tock3(logic<32> instr_i) {
    is_compressed_o = (b2(instr_i) != 0b11);
  }
  /*#
  ////////////////
  // Assertions //
  ////////////////

  // The valid_i signal used to gate below assertions must be known.
  `ASSERT_KNOWN(IbexInstrValidKnown, valid_i)

  // Selectors must be known/valid.
  `ASSERT(IbexInstrLSBsKnown, valid_i |->
      !$isunknown(instr_i[1:0]))
  `ASSERT(IbexC0Known1, (valid_i && (instr_i[1:0] == 2'b00)) |->
      !$isunknown(instr_i[15:13]))
  `ASSERT(IbexC1Known1, (valid_i && (instr_i[1:0] == 2'b01)) |->
      !$isunknown(instr_i[15:13]))
  `ASSERT(IbexC1Known2, (valid_i && (instr_i[1:0] == 2'b01) && (instr_i[15:13] == 3'b100)) |->
      !$isunknown(instr_i[11:10]))
  `ASSERT(IbexC1Known3, (valid_i &&
      (instr_i[1:0] == 2'b01) && (instr_i[15:13] == 3'b100) && (instr_i[11:10] == 2'b11)) |->
      !$isunknown({instr_i[12], instr_i[6:5]}))
  `ASSERT(IbexC2Known1, (valid_i && (instr_i[1:0] == 2'b10)) |->
      !$isunknown(instr_i[15:13]))
   #*/
};
class ModuleWithPureFunction {
public:

  // Tock methods can call pure functions.
  int get_signal1(int x) {
    return reg1 + my_pure_func(x);
  }

  // Tick methods can call pure functions.
  void update_reg() {
    reg1 = my_pure_func(reg1);
  }

private:
  int reg1;

  // This pure function is called elsewhere in the module, so it would not be
  // added to the port list even if it were public.
  int my_pure_func(int x) const {
    return x + 17;
  }

  // This pure function would appear in the port list if it were public.
  // Uncomment the line below to see the difference.
//public:
  int my_pure_func2(int x) const {
    return x + 17;
  }
};

//----------------------------------------

class ModuleWithImpureFunction {
public:
  int sig1;
  int sig2;

  // The top-level tock method will become an always_comb
  void tock1() {
    sig1 = tock2();
  }

  // This could be a function, but right now some external tools handle this
  // case weird so we emit it as an always_comb with its own set of binding
  // variables.
  int tock2() {
    sig2 = 17;
    return sig2;
  }
};

//----------------------------------------

class ModuleWithTask {
public:
  int reg1;
  int reg2;

  // The top-level tick method will become an always_ff.
  void tick1() {
    reg1 = reg1 + 1;
    tick2();
  }

  // Tick methods called by other tick methods will become tasks.
  void tick2() {
    reg2 = reg2 + 1;
  }
};
// A very basic counter in plain C++, converted to Verilog using Metron.

class Counter {
public:
  int count;
  void update() {
    count++;
  }
};
class Tutorial2 {
public:

  int get_thing() {
    return 1;
  }
};
// By default, "sum" is an output signal assigned in always_comb.
class Adder1 {
public:
  int sum;
  void add(int a, int b) {
    sum = a + b;
  }
};

// We can force Metron to emit "sum" as a register by reading from it before
// we write to it.
class Adder2 {
public:
  int sum;
  void add(int a, int b) {
    int dummy = sum;
    sum = a + b;
  }
};

// Or we can prefix the function name with "tick", which does basically the
// same thing.
class Adder3 {
public:
  int sum;
  void tick_add(int a, int b) {
    sum = a + b;
  }
};
// Tutorial 5

class Module {
public:
};
// If we try to update mutually-dependent fields in one function, we'll hit an
// error. Uncomment to see the error.

/*
class Module1 {
public:
  int a;
  int b;

  void update() {
    a = b + 1;
    b = a + 1;
  }
};
*/

// This module declares "update_a" first.
class Module2 {
public:
  int a;
  int b;

  void update_a() {
    a = b + 1;
  }

  void update_b() {
    b = a + 1;
  }
};

// This module declares "update_b" first.
class Module3 {
public:
  int a;
  int b;

  void update_b() {
    b = a + 1;
  }

  void update_a() {
    a = b + 1;
  }
};

// This module uses temporaries to update both A and B in a single function
class Module4 {
public:
  int a;
  int b;

  void update() {
    int old_a = a;
    int old_b = b;
    a = old_b + 1;
    b = old_a + 1;
  }
};
class NonBlockingAssignment {
public:
  int count;
  void update() {
    count = count + 1;
    int dummy = count;
  }
};
// Tutorial 4

class Module {
public:
};
class Adder {
public:
  int add(int a, int b) {
    return a + b;
  }
};

//----------

class Adder2 {
public:
  int a;
  int b;
  int sum;

  void add() {
    sum = a + b;
  }
};
#include "metron_tools.h"

/*
640x480x60
Pixel clock 25.175 MHz

Screen X    [000-639]
Front porch [640-655]
HSync-      [656-751]
Back porch  [752-799]

Screen Y    [000-479]
Front porch [480-489]
VSync-      [490-491]
Back porch  [492-524]
*/

class VGAOut {
 public:
  logic<1> vga_hsync;
  logic<1> vga_vsync;
  logic<1> vga_R;
  logic<1> vga_G;
  logic<1> vga_B;

  logic<10> px;
  logic<10> py;

  logic<1> in_border() const {
    return (px <= 7) || (px >= 633) || (py <= 7) || (py >= 473);
  }

  logic<1> in_checker() const {
    return px[3] ^ py[3];
  }

  void update_video() {
    vga_hsync = !((px >= 656) && (px <= 751));
    vga_vsync = !((py >= 490) && (py <= 491));

    if ((px < 640) && (py < 480)) {
      vga_R = in_border() | in_checker();
      vga_G = in_border();
      vga_B = in_border();
    } else {
      vga_R = 0;
      vga_G = 0;
      vga_B = 0;
    }
  }

  void update_counters() {
    logic<10> new_px = px + 1;
    logic<10> new_py = py;

    if (new_px == 800) {
      new_px = 0;
      new_py = new_py + 1;
    }

    if (new_py == 525) {
      new_py = 0;
    }

    px = new_px;
    py = new_py;
  }

};
// Tutorial 3

class Module {
public:
};
#include "metron_tools.h"
#include "blockram.h"

//------------------------------------------------------------------------------

class Checksum {
public:

  int get_checksum() const {
    return sum;
  }

  int get_done() const {
    return cursor == 256;
  }

  void tock(int reset) {
    logic<8> data = ram.get_data();
    ram.tick(cursor, 0, 0);
    tick(reset, data);
  }

private:

  void tick(int reset, logic<8> data) {
    if (reset) {
      cursor = 0;
      sum = 0;
    }
    else {
      if (cursor < 256) {
        cursor = cursor + 1;
        sum = sum + data;
      }
    }
  }

  int cursor;
  int sum;
  Blockram ram;
};

//------------------------------------------------------------------------------
#include "metron_tools.h"

class Module {
  // Private only so we don't spam our port list for this example
private:

  // Logic types can be indexed like arrays that return individual bits.
  logic<1> extract_bit_four(logic<16> a) {
    return a[4];
  }

  // bN(x, offset) is shorthand for bx<N>(x, offset) which extracts a slice
  // of the bits in a field. Slices that overflow the source will be padded
  // with 0.
  logic<3> extract_three_bits_starting_at_bit_four(logic<16> a) {
    return b3(a, 4);
  }

  // Logic types can be concatenated together, and the result's bit width will
  // be the sum of the bit widths of the arguments.
  logic<3> concatenate(logic<1> a, logic<1> b, logic<1> c) {
    return cat(a, b, c);
  }

  // Logic types can be duplicated, which is equivalent to cat(x, x, x...). The
  // result's bit width will be the product of the argument width and the dup
  // count.
  logic<9> duplicate_three_times(logic<3> a) {
    return dup<3>(a);
  }
};
#include "metron_tools.h"

namespace MyPackage {
  static const int ADDER_WIDTH = 17;
  static const int INCREMENT_VAL = 3;
};

template<int width>
class AdjustableAdder {
public:
  logic<width> add(logic<width> a, logic<width> b) {
    return a + b;
  }
};

class Module {
  public:
  logic<MyPackage::ADDER_WIDTH> increment(logic<MyPackage::ADDER_WIDTH> x) {
    return x + MyPackage::INCREMENT_VAL;
  }

private:
  AdjustableAdder<MyPackage::ADDER_WIDTH> my_adder;
};
#include "adder.h"
#include "counter.h"

class ModuleWithSubmodules {
public:
  int update() {
    // The field "my_counter.count" is a register, which means we can only read
    // it _before_ it is written. Uncomment this line to see the error if we
    // call update() on the counter before we send its value to the adder.
    // my_counter.update();

    // Each branch of our if() can call my_adder.add, but we can only have one
    // call to it total per code path.
    int result;
    if (1) {
      result = my_adder.add(my_counter.count, 7);
    }
    else {
      result = my_adder.add(23, my_counter.count);
    }

    // If we try to call it a second time, Metron will generate an error.
    // int result2 = my_adder.add(3, 4);

    // The counter's update() method is a tick, but the method we're currently
    // in is a tock. This cross-module, cross-tick/tock call is OK.
    my_counter.update();
    return result;
  }

private:
  // Metron will generate and bind variables to our submodules during
  // conversion so that we can "call" methods in them.
  Adder my_adder;
  Counter my_counter;
};
#include "metron_tools.h"

//------------------------------------------------------------------------------

class Blockram {
public:
  Blockram() {
    readmemh("blockram.hex", memory, 0, 255);
  }

  logic<8> get_data() const {
    return data_out;
  }

  void tick(logic<8> address, logic<1> write, logic<8> data_in) {
    if (write) {
      memory[address] = data_in;
      data_out = data_in;
    }
    else {
      data_out = memory[address];
    }
  }

private:
  logic<8> memory[256];
  logic<8> data_out;
};
#pragma once
#include <stdint.h>
#include <stdio.h>
typedef bool wire;

inline wire bit0(uint32_t w) { return wire(w & 1); }
inline wire bit(uint32_t w, int i) { return wire((w >> i) & 1); }

const bool config_use_flags = true;
const bool config_check_flags = true;
const bool config_dcheck = true;

struct triwire { wire state; };

//-----------------------------------------------------------------------------
// These _must_ be defined for all builds.

const wire BIT_DATA   = 0b00000001;
const wire TRI_DRIVEN = 0b00001000;
const wire BIT_CLOCK  = 0b00000010;

// These are only used for error checking and can be disabled in fast builds.
const wire BIT_PULLED = config_use_flags ? 0b00000100 : 0b00000000;
const wire BIT_DRIVEN = config_use_flags ? 0b00001000 : 0b00000000;
const wire BIT_OLD    = config_use_flags ? 0b00010000 : 0b00000000;
const wire BIT_NEW    = config_use_flags ? 0b00100000 : 0b00000000;
const wire TRI_NEW    = config_use_flags ? 0b00100000 : 0b00000000;

//------------------------------------------------------------------------------

#ifdef __GNUC__
#include <csignal>
#define debugbreak() raise(SIGTRAP);
#endif

#ifdef _MSC_VER
#define debugbreak() __debugbreak();
#endif

// Checks that always happen in every build.
#define CHECK_P(A)  if (!(A)) { printf("ASSERT_P fail @ %s:%d : %s\n", __FILE__, __LINE__, #A); debugbreak(); }
#define CHECK_N(A)  if ((A))  { printf("ASSERT_N fail @ %s:%d : %s\n", __FILE__, __LINE__, #A); debugbreak(); }

// Checks that only happen if "config_dcheck" is on.
#define DCHECK_P(A)   if (config_dcheck) {if (!(A)) { printf("CHECK_P fail @ %s:%d : %s\n", __FILE__, __LINE__, #A);  debugbreak(); }}
#define DCHECK_N(A)   if (config_dcheck) {if ((A))  { printf("CHECK_N fail @ %s:%d : %s\n", __FILE__, __LINE__, #A);  debugbreak(); }}

//-----------------------------------------------------------------------------

// ADDER_01
// ADDER_02
// ADDER_03 << CI
// ADDER_04
// ADDER_05
// ADDER_06 >> SO
// ADDER_07
// ADDER_08
// ADDER_09
// ADDER_10 >> CO
// ADDER_11
// ADDER_12
// ADDER_13
// ADDER_14
// ADDER_15
// ADDER_16 << A
// ADDER_17 << B
// ADDER_18
// ADDER_19
// ADDER_20

struct Adder {
  wire sum;
  wire carry;
};

inline Adder add3(wire a, wire b, wire c) {
  uint8_t s = bit0(a) + bit0(b) + bit0(c);
  return { bit(s, 0), bit(s, 1) };
}

// this is in rung order
inline Adder add3b(wire ci, wire a, wire b) {
  uint8_t s = bit0(a) + bit0(b) + bit0(ci);
  return { bit(s, 0), bit(s, 1) };
}

//-----------------------------------------------------------------------------

struct BitBase {
  BitBase() : state(0) {}
  //BitBase(uint8_t _state) : state(_state) {}

  wire qp_old() const { check_old(); return state; }
  wire qn_old() const { check_old(); return ~state; }

  wire qp_mid() const { return state; }
  wire qn_mid() const { return ~state; }

  wire qp_any() const { return state; }
  wire qn_any() const { return ~state; }

  wire qp_new() const { check_new(); return state; }
  wire qn_new() const { check_new(); return ~state; }

  //----------
  // stuff in this section for logic mode only

  //operator bool() const { return get_data(); }
  //BitBase operator~() const { BitBase b; b.state = ~state; return b; }
  //BitBase operator^(const BitBase& b) const { return BitBase(state ^ b.state); }

  void rst() { state &= ~1; }
  void set() { state |= 1; }

  wire get_data() const { return bit0(state); }
  void set_data(wire d) { state = (state & ~1) | bit0(d); }

  wire get_clk() const { return bit(state, 1); }
  void set_clk(wire c) { state = (state & ~2) | (bit0(c) << 1); }

  void dff_pp(wire CLKp, wire Dp) {
    wire clk_old = state & BIT_CLOCK;
    wire clk_new = (CLKp << 1) & BIT_CLOCK;
    wire d1 = (~clk_old & clk_new) ? Dp : state;
    state = uint8_t(bit0(d1) | clk_new | BIT_NEW | BIT_DRIVEN);
  }

  //----------

  void check_old() const {
    if (config_check_flags) {
      CHECK_P(bool(state & BIT_DRIVEN) != bool(state & BIT_PULLED));
      CHECK_P((state & (BIT_OLD | BIT_NEW)) == BIT_OLD);
    }
  }

  void check_new() const {
    if (config_check_flags) {
      CHECK_P(bool(state & BIT_DRIVEN) != bool(state & BIT_PULLED));
      CHECK_P((state & (BIT_OLD | BIT_NEW)) == BIT_NEW);
    }
  }

  void check_invalid() const {
    if (config_check_flags) {
      CHECK_N(state & (BIT_OLD | BIT_NEW));
    }
  }

  uint8_t state;

  // need default = for bit_purge
  //BitBase& operator=(const BitBase&) = delete;
};

static_assert(sizeof(BitBase) == 1, "Bad BitBase size");


inline wire bit(const BitBase& b) { return b.get_data(); }

//-----------------------------------------------------------------------------

struct Gate : public BitBase {
  wire out_any() const { return state; }
  wire out_old() const { check_old(); return state; }
  wire out_mid() const { return state; }
  wire out_new() const { check_new(); return state; }

  void hold() {
    state = uint8_t(BIT_NEW | BIT_DRIVEN | bit0(state));
  }

  void operator<<= (wire D) {
    //check_unset(); // we use this in feeback loops, need better check...
    state = uint8_t(BIT_NEW | BIT_DRIVEN | bit0(D));
  }
};

//-----------------------------------------------------------------------------

struct SigIn : public BitBase {
  wire out_any() const { return state; }
  wire out_old() const { check_old(); return state; }
  wire out_new() const { check_new(); return state; }

  void sig_in(wire D) {
    check_invalid();
    state = uint8_t(BIT_NEW | BIT_DRIVEN | bit0(D));
  }
};

//-----------------------------------------------------------------------------

struct SigOut : public BitBase {
  wire out_old() const { check_old(); return state; }
  wire out_new() const { check_new(); return state; }

  void sig_out(wire D) {
    check_invalid();
    state = uint8_t(BIT_NEW | BIT_DRIVEN | bit0(D));
  }
};

//-----------------------------------------------------------------------------
// Generic DFF

struct DFF : public BitBase {
  void dff_r(wire CLKp, wire RSTn, wire Dp) {
    check_invalid();

    wire clk_old = state & BIT_CLOCK;
    wire clk_new = (CLKp << 1) & BIT_CLOCK;

    wire d1 = (~clk_old & clk_new) ? Dp : state;

    state = uint8_t(bit0(d1 & RSTn) | clk_new | BIT_NEW | BIT_DRIVEN);
  }
};

//-----------------------------------------------------------------------------
// 8-rung register with no reset, inverting input, and dual outputs. Used by
// sprite store, bg pix a, spr pix a/b, dma hi, bus mux sprite temp

// DFF8_01 |o------O | << CLKn
// DFF8_02 |====O====| << Dn
// DFF8_03 |  -----  |
// DFF8_04 |O-------o| << CLKp
// DFF8_05 |  -----  |
// DFF8_06 |==     ==|
// DFF8_07 |xxx-O-xxx| >> Qn
// DFF8_08 |xxx-O-xxx| >> Q  or this rung can be empty

struct DFF8n : public BitBase {
  void dff8n(wire CLKn, wire Dn) {
    check_invalid();

    wire clk_old = state & BIT_CLOCK;
    wire clk_new = (~CLKn << 1) & BIT_CLOCK;

    wire d1 = (~clk_old & clk_new) ? ~Dn : state;

    state = uint8_t(bit0(d1) | clk_new | BIT_NEW | BIT_DRIVEN);
  }
};

//-----------------------------------------------------------------------------
// same w/ swapped clock inputs, not 100% positive this is correct but BGP has
// to latch on the rising edge of the clock or m3_bgp_change is way off.

// DFF8_01 |o------O | << CLKp
// DFF8_02 |====O====| << Dn
// DFF8_03 |  -----  |
// DFF8_04 |O-------o| << CLKn
// DFF8_05 |  -----  |
// DFF8_06 |==     ==|
// DFF8_07 |xxx-O-xxx| >> Qn
// DFF8_08 |xxx-O-xxx| >> Q  or this rung can be empty

struct DFF8p : public BitBase {
  void dff8p(wire CLKp, wire Dn) {
    check_invalid();

    wire clk_old = state & BIT_CLOCK;
    wire clk_new = (CLKp << 1) & BIT_CLOCK;

    wire d1 = (~clk_old & clk_new) ? ~Dn : state;

    state = uint8_t(bit0(d1) | clk_new | BIT_NEW | BIT_DRIVEN);
  }
};

//-----------------------------------------------------------------------------
// 9-rung register with async _set_?, inverting input, and dual outputs. Looks like
// Reg8 with a hat and a belt. Used by clock phase (CHECK), LYC, BGP, OBP0,
// OBP1, stat int enable, sprite store, SCY, SCX, LCDC, WX, WY.

// DFF9_01 | O===--o |
// DFF9_02 |==--O====| << CLKp
// DFF9_03 | ------- | << D
// DFF9_04 |o-------O| << CLKn
// DFF9_05 |  -----  |
// DFF9_06 |--xxOxx--| << RSTn
// DFF9_07 |o-------o|
// DFF9_08 |xxx-O-xxx| >> Qn
// DFF9_09 |xxx-O-xxx| >> Q

struct DFF9 : public BitBase {
  void dff9(wire CLKp, wire SETn, wire Dn) {
    check_invalid();

    wire clk_old = state & BIT_CLOCK;
    wire clk_new = (CLKp << 1) & BIT_CLOCK;

    wire d1 = (~clk_old & clk_new) ? ~Dn : state;

    state = uint8_t(bit0(d1 | (~SETn)) | clk_new | BIT_NEW | BIT_DRIVEN);
  }
};

//-----------------------------------------------------------------------------
// Reg11 is used by the background pixel temp state
// Not sure why it's special.

// DFF11_01 nc
// DFF11_02 << RSTp? // FIXME trace this
// DFF11_03 << D
// DFF11_04 nc
// DFF11_05 << CLKp
// DFF11_06 nc
// DFF11_07 nc
// DFF11_08 << CLKn
// DFF11_09 << RSTn
// DFF11_10 nc
// DFF11_11 >> Qp?

struct DFF11 : public BitBase {
  void dff11(wire CLKp, wire RSTn, wire Dp) {
    check_invalid();
    wire clk_old = state & BIT_CLOCK;
    wire clk_new = (CLKp << 1) & BIT_CLOCK;

    wire d1 = (~clk_old & clk_new) ? Dp : state;

    state = uint8_t(bit0(d1 & RSTn) | clk_new | BIT_NEW | BIT_DRIVEN);
  }
};

//-----------------------------------------------------------------------------

// DFF13_01 nc
// DFF13_02 << RSTn
// DFF13_03 << D
// DFF13_04 nc
// DFF13_05 << CLKp
// DFF13_06 nc
// DFF13_07 nc
// DFF13_08 << CLKn
// DFF13_09 << RSTn
// DFF13_10 nc
// DFF13_11 nc
// DFF13_12 >> Qn
// DFF13_13 >> Q

struct DFF13 : public BitBase {
  void dff13(wire CLKp, wire RSTn, wire Dp) {
    check_invalid();
    wire clk_old = state & BIT_CLOCK;
    wire clk_new = (CLKp << 1) & BIT_CLOCK;

    wire d1 = (~clk_old & clk_new) ? Dp : state;

    state = uint8_t(bit0(d1 & RSTn) | clk_new | BIT_NEW | BIT_DRIVEN);
  }
};

//-----------------------------------------------------------------------------
// DFF17_01 SC
// DFF17_02 << CLKp
// DFF17_03 SC
// DFF17_04 --
// DFF17_05 --
// DFF17_06 << RSTn  // must be RSTn, see WUVU/VENA/WOSU
// DFF17_07 << D
// DFF17_08 --
// DFF17_09 SC
// DFF17_10 --
// DFF17_11 --
// DFF17_12 SC
// DFF17_13 << RSTn
// DFF17_14 --
// DFF17_15 --
// DFF17_16 >> QN   _MUST_ be QN - see TERO
// DFF17_17 >> Q    _MUST_ be Q  - see TERO

struct DFF17 : public BitBase {
  void dff(wire CLKp, wire Dp) {
    check_invalid();
    wire clk_old = state & BIT_CLOCK;
    wire clk_new = (CLKp << 1) & BIT_CLOCK;

    wire d1 = (~clk_old & clk_new) ? Dp : state;

    state = uint8_t(bit0(d1) | clk_new | BIT_NEW | BIT_DRIVEN);
  }


  void dff17(wire CLKp, wire RSTn, wire Dp) {
    check_invalid();
    dff17_any(CLKp, RSTn, Dp);
  }

  void dff17_any(wire CLKp, wire RSTn, wire Dp) {
    wire clk_old = state & BIT_CLOCK;
    wire clk_new = (CLKp << 1) & BIT_CLOCK;

    wire d1 = (~clk_old & clk_new) ? Dp : state;

    state = uint8_t(bit0(d1 & RSTn) | clk_new | BIT_NEW | BIT_DRIVEN);
  }
};

//-----------------------------------------------------------------------------
// 20-rung counter ff with async load. Only used by TIMA and a few audio regs.

// DFF20_01 >> Q
// DFF20_02 nc
// DFF20_03 << D
// DFF20_04 << LOADp
// DFF20_05 nc
// DFF20_06 sc
// DFF20_07 nc
// DFF20_08 nc
// DFF20_09 nc
// DFF20_10 nc
// DFF20_11 sc
// DFF20_12 nc
// DFF20_13 nc
// DFF20_14 << LOADp
// DFF20_15 nc
// DFF20_16 << D
// DFF20_17 >> Qn
// DFF20_18 sc
// DFF20_19 sc
// DFF20_20 << CLKn

struct DFF20 : public BitBase {
  void dff20_any(wire CLKn, wire LOADp, wire newD) {
    wire clk_old = bit0(state >> 1);
    wire clk_new = bit0(~CLKn);

    state = bit0(state);

    if (!bit0(clk_old) && bit0(clk_new)) {
      state = !state;
    }

    state |= (clk_new << 1);
    state |= BIT_NEW;
    state |= BIT_DRIVEN;

    if (bit0(LOADp)) {
      state &= ~1;
      state |= bit0(newD);
    }
  }

  void dff20(wire CLKn, wire LOADp, wire newD) {
    check_invalid();
    dff20_any(CLKn, LOADp, newD);
  }
};

//-----------------------------------------------------------------------------
// DFF with async set/reset. Used by pixel pipes, serial data register.

// SETn/RSTn are correct and not swapped, see serial + ALUR_RSTn

// DFF22_01 sc
// DFF22_02 nc
// DFF22_03 nc
// DFF22_04 nc
// DFF22_05 sc
// DFF22_06 sc
// DFF22_07 << D
// DFF22_08 nc
// DFF22_09 sc
// DFF22_10 nc
// DFF22_11 sc
// DFF22_12 nc
// DFF22_13 nc
// DFF22_14 << SETn _MUST_ be SETn, see serial
// DFF22_15 >> Qn
// DFF22_16 >> Q
// DFF22_17 << RSTn _MUST_ be RSTn, see serial
// DFF22_18 nc
// DFF22_19 sc
// DFF22_20 sc
// DFF22_21 sc
// DFF22_22 << CLKp

struct DFF22 : public BitBase {
  void dff22_any(wire CLKp, wire SETn, wire RSTn, wire Dp) {
    wire clk_old = state & BIT_CLOCK;
    wire clk_new = (CLKp << 1) & BIT_CLOCK;

    wire d1 = (~clk_old & clk_new) ? Dp : state;

    state = uint8_t(bit0((d1 | (~SETn)) & RSTn) | clk_new | BIT_NEW | BIT_DRIVEN);
  }

  void dff22(wire CLKp, wire SETn, wire RSTn, wire Dp) {
    check_invalid();
    dff22_any(CLKp, SETn, RSTn, Dp);
  }

  void dff22_sync(wire CLKp, wire Dp) {
    check_invalid();
    wire clk_old = state & BIT_CLOCK;
    wire clk_new = (CLKp << 1) & BIT_CLOCK;
    wire d1 = (~clk_old & clk_new) ? Dp : state;
    state = uint8_t(bit0(d1) | clk_new | BIT_DRIVEN);
  }

  void dff22_async(wire SETn, wire RSTn) {
    check_invalid();
    wire clk_new = state & BIT_CLOCK;
    state = uint8_t(bit0((state | (~SETn)) & RSTn) | clk_new | BIT_NEW | BIT_DRIVEN);
  }
};

//-----------------------------------------------------------------------------
// Bus with pull-up

// TYGO_01 << BUS_CPU_D2p
// TYGO_02 nc
// TYGO_03 nc
// TYGO_04 nc
// TYGO_05 << RAHU_04
// TYGO_06 << BUS_CPU_D2p
// TYGO_07 nc
// TYGO_08 nc
// TYGO_09 >> BUS_VRAM_D2p
// TYGO_10 nc

// tri6_nn : top rung tadpole _not_ facing second rung dot.
// tri6_pn : top rung tadpole facing second rung dot.

// TRI6NN_01 :
// TRI6NN_02 : NC
// TRI6NN_03 : NC
// TRI6NN_04 :
// TRI6NN_05 : NC
// TRI6NN_06 :

inline triwire tri_pp(wire OEp, wire Dp) {
  return { wire(bit0(OEp) ? TRI_NEW | TRI_DRIVEN | bit0(Dp) : TRI_NEW) };
}

inline triwire tri6_nn(wire OEn, wire Dn) {
  return { wire(bit0(OEn) ? TRI_NEW : TRI_NEW | TRI_DRIVEN | bit0(~Dn)) };
}

inline triwire tri6_pn(wire OEp, wire Dn) {
  return { wire(bit0(OEp) ? TRI_NEW | TRI_DRIVEN | bit0(~Dn) : TRI_NEW) };
}

inline triwire tri10_np(wire OEn, wire Dp) {
  return { wire(bit0(OEn) ? TRI_NEW : TRI_NEW | TRI_DRIVEN | bit0(Dp)) };
}

struct Bus : public BitBase {
  wire out_old() const { check_old(); return state; }
  wire out_any() const { return state; }
  wire out_mid() const { return state; }
  wire out_new() const { check_new(); return state; }

  void tri_bus(triwire t) {
    check_new();

    // if both the new and old state are both driven, that's a bus collision.
    DCHECK_N((t.state & TRI_DRIVEN) && (state & BIT_DRIVEN));

    if (t.state & TRI_DRIVEN) state = t.state;
  }
};

//-----------------------------------------------------------------------------
// Pin structs store the bit as it apperas INSIDE the chip. Bits are inverted
// when traveling across the chip boundary.

struct PinBase : public BitBase {
  PinBase(uint8_t _state) {
    state = _state;
  }

  wire qp_int_old() const { return qp_old(); }
  wire qp_int_any() const { return qp_any(); }
  wire qp_int_new() const { return qp_new(); }

  wire qp_ext_old() const { return qn_old(); }
  wire qp_ext_new() const { return qn_new(); }
  wire qn_ext_new() const { return qp_new(); }
};

struct PinIO : public PinBase {
  PinIO() : PinBase(0) {}
  void pin_io(wire int_PUn, wire int_HI, wire int_LO, wire ext_OEp, wire ext_Dp) {
    check_invalid();
    pin_io_any(int_PUn, int_HI, int_LO, ext_OEp, ext_Dp);
  }

  void pin_io_any(wire int_PUn, wire int_HI, wire int_LO, wire ext_OEp, wire ext_Dp) {
    (void)int_PUn;

    if (bit0(int_HI) == bit0(int_LO)) {
      state = uint8_t(BIT_NEW | BIT_DRIVEN | bit0(int_LO));
    }
    else {
      if (bit0(int_LO)) {
        // shootthrough, this is bad
        DCHECK_P(false);
      }
      else {
        // hi-z, can be driven externally
        DCHECK_N(bit0(int_PUn)); // must not be floating

        // this is the _internal_ bit, so if this is pulled high externally it should read 0 internally.
        // i think...
        state = BIT_NEW | BIT_PULLED | 0;

        //state = BIT_NEW | BIT_PULLED | 1;
      }
    }

    if (bit0(ext_OEp)) {
      DCHECK_N(state & BIT_DRIVEN);
      // External bit is inverted when crossing the pin
      state = uint8_t(BIT_NEW | BIT_DRIVEN | bit0(~ext_Dp));
    }

    DCHECK_P(bool(state & BIT_DRIVEN) != bool(state & BIT_PULLED));
    DCHECK_P(bool(state & BIT_NEW));
  }
};

//-----------------------------------------------------------------------------

struct PinIn : public PinBase {
  PinIn() : PinBase(0) {};
  PinIn(uint8_t _state) : PinBase(_state) {}

  void pin_in(wire ext_Dp) {
    check_invalid();
    state = ((~ext_Dp) & BIT_DATA) | BIT_DRIVEN | BIT_NEW;
  }
};

//-----------------------------------------------------------------------------

struct PinOut : public PinBase {
  PinOut() : PinBase(0) {}
  void pin_out(wire int_HI, wire int_LO) {
    check_invalid();

    if (!bit0(int_HI) && !bit0(int_LO)) {
      // internal bit 0, external bit 1
      state = BIT_NEW | BIT_DRIVEN | 0;
    }
    else if (bit0(int_HI) && bit0(int_LO)) {
      // internal bit 1, external bit 0
      state = BIT_NEW | BIT_DRIVEN | 1;
    }
    else if (bit0(int_HI) && !bit0(int_LO)) {
      state = BIT_NEW;
    }
    else if (!bit0(int_HI) && bit0(int_LO)) {
      // shootthrough, this is bad
      debugbreak();
    }
  }
};

//-----------------------------------------------------------------------------

struct PinClock {
  wire clkgood_old() const { return CLKGOOD.qp_int_old(); }
  wire clk_old()     const { return CLK.qp_int_old(); }

  wire clkgood_new() const { return CLKGOOD.qp_int_new(); }
  wire clk_new()     const { return CLK.qp_int_new(); }

  void pin_clk(wire clk, wire clkgood) {
    CLK.pin_in(clk);
    CLKGOOD.pin_in(clkgood);
  }

  PinIn CLK;
  PinIn CLKGOOD;
};

//-----------------------------------------------------------------------------
// 6-rung cell, "arms" on ground side

// NORLATCH_01 -|=== o ===|+ << SET
// NORLATCH_02 -|--\      |+ nc
// NORLATCH_03 -|=== o ===|+ >> QN
// NORLATCH_04 -|=== o ===|+ >> Q
// NORLATCH_05 -|--/      |+ nc
// NORLATCH_06 -|=== o ===|+ << RST

struct NorLatch : public BitBase {
  void rst() {
    state = BIT_DRIVEN | BIT_NEW | 0;
  }

  void nor_latch(wire SETp, wire RSTp) {
    check_invalid();
    state |= SETp;
    state &= ~RSTp;

    state = (state & BIT_DATA) | BIT_DRIVEN | BIT_NEW;
  }
};

//-----------------------------------------------------------------------------
// 6-rung cell, "arms" on VCC side. Only TAKA/LONY seem to use this cell

// NANDLATCH_01 -|=== o ===|+ << SETn
// NANDLATCH_02 -|      /--|+ nc
// NANDLATCH_03 -|=== o ===|+ >> Q
// NANDLATCH_04 -|=== o ===|+ >> QN
// NANDLATCH_05 -|      \--|+ nc
// NANDLATCH_06 -|=== o ===|+ << RSTn

struct NandLatch : public BitBase {
  void nand_latch(wire SETn, wire RSTn) {
    check_invalid();
    state |= ~SETn;
    state &= RSTn;

    state = (state & BIT_DATA) | BIT_DRIVEN | BIT_NEW;
  }
};

//-----------------------------------------------------------------------------
// Yellow 10-rung cells on die. Transparent latch, probably.

// TPLATCH_01 << HOLDn
// TPLATCH_02 nc
// TPLATCH_03 << D
// TPLATCH_04 nc
// TPLATCH_05 nc
// TPLATCH_06 nc
// TPLATCH_07 nc
// TPLATCH_08 >> Q
// TPLATCH_09 nc
// TPLATCH_10 >> Qn

// Output 08 must _not_ be inverting, see pin EXT_A14p
// Output 10 _must_ be inverting...?

// FIXME - why do we have latchN and latchP?

struct TpLatch : public BitBase {
  void tp_latchn(wire HOLDn, wire Dp) {
    check_invalid();
    wire SETp = HOLDn & Dp;
    wire RSTp = HOLDn & ~Dp;

    state |= SETp;
    state &= ~RSTp;

    state = (state & BIT_DATA) | BIT_DRIVEN | BIT_NEW;
  }

  void tp_latchp(wire HOLDp, wire Dp) {
    check_invalid();
    wire SETp = (~HOLDp) & Dp;
    wire RSTp = (~HOLDp) & ~Dp;

    state |= SETp;
    state &= ~RSTp;

    state = (state & BIT_DATA) | BIT_DRIVEN | BIT_NEW;
  }
};

//-----------------------------------------------------------------------------
/// plait_noparse

#pragma once

#include "gates.h"
#include "regs.h"

struct SpuControl {
  //----------
  // clocks for the apu

  /*_p01.CERY*/ DFF17 CERY_2M;
  /*_p01.ATYK*/ DFF17 ATYK_2M;
  /*_p01.AVOK*/ DFF17 AVOK_1M;
  /*_p09.AJER*/ DFF17 AJER_2M;
  /*_p01.JESO*/ DFF17 JESO_CLK_512K;

  /*_p01.BARA*/ DFF17 BARA_CLK_512;
  /*_p01.CARU*/ DFF17 CARU_CLK_256;
  /*_p01.BYLU*/ DFF17 BYLU_CLK_128;
};

struct SpuChannel1 {
  /*#p11.BANY*/ DFF9 BANY_NR10_SWEEP_SHIFT0;
  /*#p11.ARAX*/ DFF9 ARAX_NR10_SWEEP_SHIFT1;
  /*#p11.ANAZ*/ DFF9 ANAZ_NR10_SWEEP_SHIFT2;
  /*#p11.AVAF*/ DFF9 AVAF_NR10_SWEEP_NEGATE;
  /*#p11.ADEK*/ DFF9 ADEK_NR10_SWEEP_PERIOD0;
  /*#p11.BANA*/ DFF9 BANA_NR10_SWEEP_PERIOD1;
  /*#p11.BOTU*/ DFF9 BOTU_NR10_SWEEP_PERIOD2;

  //----------

  /*_p11.CENA*/ DFF9  CENA_NR11_DUTY_0;
  /*_p11.DYCA*/ DFF9  DYCA_NR11_DUTY_1;
  /*_p13.BACY*/ DFF20 BACY_NR11_LEN0;
  /*_p13.CAVY*/ DFF20 CAVY_NR11_LEN1;
  /*_p13.BOVY*/ DFF20 BOVY_NR11_LEN2;
  /*_p13.CUNO*/ DFF20 CUNO_NR11_LEN3;
  /*_p13.CURA*/ DFF20 CURA_NR11_LEN4;
  /*_p13.ERAM*/ DFF20 ERAM_NR11_LEN5;

  //----------

  /*_p11.JUSA*/ DFF9 JUSA_NR12_DELAY0;
  /*_p11.JUZY*/ DFF9 JUZY_NR12_DELAY1;
  /*_p11.JOMA*/ DFF9 JOMA_NR12_DELAY2;
  /*_p11.JAFY*/ DFF9 JAFY_NR12_ENV_DIR;
  /*_p11.JATY*/ DFF9 JATY_NR12_VOL0;
  /*_p11.JAXO*/ DFF9 JAXO_NR12_VOL1;
  /*_p11.JENA*/ DFF9 JENA_NR12_VOL2;
  /*_p11.JOPU*/ DFF9 JOPU_NR12_VOL3;

  //----------

  /*_p11.BOKO*/ DFF9 BOKO_NR14_LEN_EN;
  /*#p13.DUPE*/ DFF9 DUPE_NR14_TRIG;

  //========================================
  //             CHANNEL 1
  //========================================

  /*#p13.CYTO*/ NorLatch CYTO_CH1_ACTIVEp;

  /*#p13.EZEC*/ DFF17 EZEC_CH1_TRIGn;

  /*_p12.HYKA*/ DFF22 HYKA_CH1_FREQ00;
  /*_p12.JYKA*/ DFF22 JYKA_CH1_FREQ01;
  /*_p12.HAVO*/ DFF22 HAVO_CH1_FREQ02;
  /*_p12.EDUL*/ DFF22 EDUL_CH1_FREQ03;
  /*_p12.FELY*/ DFF22 FELY_CH1_FREQ04;
  /*_p12.HOLU*/ DFF22 HOLU_CH1_FREQ05;
  /*_p12.HYXU*/ DFF22 HYXU_CH1_FREQ06;
  /*_p12.HOPO*/ DFF22 HOPO_CH1_FREQ07;
  /*_p12.DYGY*/ DFF22 DYGY_CH1_FREQ08;
  /*_p12.EVAB*/ DFF22 EVAB_CH1_FREQ09;
  /*_p12.AXAN*/ DFF22 AXAN_CH1_FREQ10;

  /*_p09.CALO*/ DFF17 CALO_CLK_1M;

  /*_p13.FEKU*/ DFF17 FEKU_CH1_TRIGp;
  /*_p13.FARE*/ DFF17 FARE_CH1_TRIGp;
  /*_p13.FYTE*/ DFF17 FYTE_CH1_TRIGp;

  /*_p13.BYTE*/ DFF17 BYTE_SHIFT_DONE;

  /*_p13.CERO*/ DFF17 CERO_CH1_LEN_DONE;

  /*_p11.GAXE*/ DFF20 GAXE_CH1_FREQ_CNT_00;
  /*_p11.HYFE*/ DFF20 HYFE_CH1_FREQ_CNT_01;
  /*_p11.JYTY*/ DFF20 JYTY_CH1_FREQ_CNT_02;
  /*_p11.KYNA*/ DFF20 KYNA_CH1_FREQ_CNT_03;
  /*_p11.JEMA*/ DFF20 JEMA_CH1_FREQ_CNT_04;
  /*_p11.HYKE*/ DFF20 HYKE_CH1_FREQ_CNT_05;
  /*_p11.FEVA*/ DFF20 FEVA_CH1_FREQ_CNT_06;
  /*_p11.EKOV*/ DFF20 EKOV_CH1_FREQ_CNT_07;
  /*_p11.EMUS*/ DFF20 EMUS_CH1_FREQ_CNT_08;
  /*_p11.EVAK*/ DFF20 EVAK_CH1_FREQ_CNT_09;
  /*_p11.COPU*/ DFF20 COPU_CH1_FREQ_CNT_10;  

  /*#p09.BAZA*/ DFF17 BAZA_DBG_SWEEP_CLK;
  /*_p13.BEXA*/ DFF17 BEXA_SWEEP_TRIGGERp;
  /*_p13.CUPO*/ DFF20 CUPO_SWEEP_DELAY0;
  /*_p13.CYPU*/ DFF20 CYPU_SWEEP_DELAY1;
  /*_p13.CAXY*/ DFF20 CAXY_SWEEP_DELAY2;

  /*_p12.FABU*/ DFF22 FABU_CH1_SHIFT00;
  /*_p12.JEFA*/ DFF22 JEFA_CH1_SHIFT01;
  /*_p12.GOGA*/ DFF22 GOGA_CH1_SHIFT02;
  /*_p12.JOLU*/ DFF22 JOLU_CH1_SHIFT03;
  /*_p12.JOTA*/ DFF22 JOTA_CH1_SHIFT04;
  /*_p12.FUDE*/ DFF22 FUDE_CH1_SHIFT05;
  /*_p12.FEDO*/ DFF22 FEDO_CH1_SHIFT06;
  /*_p12.EXAC*/ DFF22 EXAC_CH1_SHIFT07;
  /*_p12.ELUX*/ DFF22 ELUX_CH1_SHIFT08;
  /*_p12.AGEZ*/ DFF22 AGEZ_CH1_SHIFT09;
  /*_p12.BEKU*/ DFF22 BEKU_CH1_SHIFT10;

  /*_p12.GALO*/ DFF11 GALO_SUM_A00;
  /*_p12.JODE*/ DFF11 JODE_SUM_A01;
  /*_p12.KARE*/ DFF11 KARE_SUM_A02;
  /*_p12.JYME*/ DFF11 JYME_SUM_A03;
  /*_p12.GYME*/ DFF11 GYME_SUM_A04;
  /*_p12.FAXO*/ DFF11 FAXO_SUM_A05;
  /*_p12.EXAP*/ DFF11 EXAP_SUM_A06;
  /*_p12.DELE*/ DFF11 DELE_SUM_A07;
  /*_p12.DEXE*/ DFF11 DEXE_SUM_A08;
  /*_p12.DOFY*/ DFF11 DOFY_SUM_A09;
  /*_p12.DOLY*/ DFF11 DOLY_SUM_A10;

  /*_p12.HORA*/ DFF11 HORA_SUM_B00;
  /*_p12.HOPA*/ DFF11 HOPA_SUM_B01;
  /*_p12.HELE*/ DFF11 HELE_SUM_B02;
  /*_p12.JAPE*/ DFF11 JAPE_SUM_B03;
  /*_p12.JETE*/ DFF11 JETE_SUM_B04;
  /*_p12.GELE*/ DFF11 GELE_SUM_B05;
  /*_p12.EPYR*/ DFF11 EPYR_SUM_B06;
  /*_p12.EDOK*/ DFF11 EDOK_SUM_B07;
  /*_p12.DEFA*/ DFF11 DEFA_SUM_B08;
  /*_p12.ETER*/ DFF11 ETER_SUM_B09;
  /*_p12.DEVA*/ DFF11 DEVA_SUM_B10;

  /*_p13.FEMU*/ NandLatch FEMU_SHIFTINGn;

  /*#p13.COPA*/ DFF20 COPA_SHIFTCNT0;
  /*#p13.CAJA*/ DFF20 CAJA_SHIFTCNT1;
  /*#p13.BYRA*/ DFF20 BYRA_SHIFTCNT2;

  /*_p13.FYFO*/ NorLatch FYFO_CH1_TRIGn;
  /*_p13.COMY*/ DFF17 COMY_PHASE_CLK;
  /*_p13.GEXU*/ NandLatch GEXU_FREQ_GATE;

  /*_p13.ESUT*/ DFF17 ESUT_PHASE_xBxDxFxH;
  /*_p13.EROS*/ DFF13 EROS_PHASE_xxCDxxGH;
  /*_p13.DAPE*/ DFF13 DAPE_PHASE_xxxxEFGH;

  /*#p13.KOZY*/ DFF17 KOZY_ENV_CLK;
  /*#p13.KYNO*/ DFF17 KYNO_ENV_STOP;

  /*_p13.JOVA*/ DFF20 JOVA_ENV_DELAY0;
  /*_p13.KENU*/ DFF20 KENU_ENV_DELAY1;
  /*_p13.KERA*/ DFF20 KERA_ENV_DELAY2;  

  /*_p13.HEVO*/ DFF20 HEVO_CH1_ENV3;
  /*_p13.HOKO*/ DFF20 HOKO_CH1_ENV2;
  /*_p13.HEMY*/ DFF20 HEMY_CH1_ENV1;
  /*_p13.HAFO*/ DFF20 HAFO_CH1_ENV0;

  /*_p13.KALY*/ DFF17 KALY_CLK_64;

  /*_p13.DUWO*/ DFF17 DUWO_RAW_BIT_SYNC;
  /*#p13.KEZU*/ NorLatch KEZU;
};

//-----------------------------------------------------------------------------

struct SpuChannel2 {
};

//-----------------------------------------------------------------------------

struct SpuChannel3 {
};

//-----------------------------------------------------------------------------

struct SpuChannel4 {
};

//-----------------------------------------------------------------------------

struct GBSound {
  SpuControl  spu;
  SpuChannel1 ch1;
  SpuChannel2 ch2;
  SpuChannel3 ch3;
  SpuChannel4 ch4;

  /*#p15.CEMO*/ DFF17 CEMO_1MHZ;
  /*_p15.ATEP*/ DFF17 ATEP_2MHZ;

  /*_BUS_CPU_A00p*/ Bus BUS_CPU_A00p;
  /*_BUS_CPU_A01p*/ Bus BUS_CPU_A01p;
  /*_BUS_CPU_A02p*/ Bus BUS_CPU_A02p;
  /*_BUS_CPU_A03p*/ Bus BUS_CPU_A03p;
  /*_BUS_CPU_A04p*/ Bus BUS_CPU_A04p;
  /*_BUS_CPU_A05p*/ Bus BUS_CPU_A05p;
  /*_BUS_CPU_A06p*/ Bus BUS_CPU_A06p;
  /*_BUS_CPU_A07p*/ Bus BUS_CPU_A07p;
  /*_BUS_CPU_A08p*/ Bus BUS_CPU_A08p;
  /*_BUS_CPU_A09p*/ Bus BUS_CPU_A09p;
  /*_BUS_CPU_A10p*/ Bus BUS_CPU_A10p;
  /*_BUS_CPU_A11p*/ Bus BUS_CPU_A11p;
  /*_BUS_CPU_A12p*/ Bus BUS_CPU_A12p;
  /*_BUS_CPU_A13p*/ Bus BUS_CPU_A13p;
  /*_BUS_CPU_A14p*/ Bus BUS_CPU_A14p;
  /*_BUS_CPU_A15p*/ Bus BUS_CPU_A15p;

  /*_BUS_CPU_D00p*/ Bus BUS_CPU_D00p;
  /*_BUS_CPU_D01p*/ Bus BUS_CPU_D01p;
  /*_BUS_CPU_D02p*/ Bus BUS_CPU_D02p;
  /*_BUS_CPU_D03p*/ Bus BUS_CPU_D03p;
  /*_BUS_CPU_D04p*/ Bus BUS_CPU_D04p;
  /*_BUS_CPU_D05p*/ Bus BUS_CPU_D05p;
  /*_BUS_CPU_D06p*/ Bus BUS_CPU_D06p;
  /*_BUS_CPU_D07p*/ Bus BUS_CPU_D07p;

  /*_BUS_WAVE_D00p*/ Bus BUS_WAVE_D00p;
  /*_BUS_WAVE_D01p*/ Bus BUS_WAVE_D01p;
  /*_BUS_WAVE_D02p*/ Bus BUS_WAVE_D02p;
  /*_BUS_WAVE_D03p*/ Bus BUS_WAVE_D03p;
  /*_BUS_WAVE_D04p*/ Bus BUS_WAVE_D04p;
  /*_BUS_WAVE_D05p*/ Bus BUS_WAVE_D05p;
  /*_BUS_WAVE_D06p*/ Bus BUS_WAVE_D06p;
  /*_BUS_WAVE_D07p*/ Bus BUS_WAVE_D07p;

  //----------
  // active flags

  /*_p15.DANE*/ NorLatch DANE_CH2_ACTIVE;
  /*_p18.DAVO*/ DFF17    DAVO_CH3_ACTIVEp;
  /*_p20.GENA*/ NorLatch GENA_CH4_ACTIVE;

  //----------

  /*_p15.ERYC*/ DFF20 ERYC_NR21_L0;
  /*_p15.CERA*/ DFF20 CERA_NR21_L1;
  /*_p15.CONU*/ DFF20 CONU_NR21_L2;
  /*_p15.CAME*/ DFF20 CAME_NR21_L3;
  /*_p15.BUVA*/ DFF20 BUVA_NR21_L4;
  /*_p15.AKYD*/ DFF20 AKYD_NR21_L5;
  /*_p14.BERA*/ DFF9  BERA_NR21_D6;
  /*_p14.BAMY*/ DFF9  BAMY_NR21_D7;

  //----------
  // FF17 NR22 - channel 2 vol/env/period

  /*_p14.HYFU*/ DFF9 HYFU_NR22_P0;
  /*_p14.HORE*/ DFF9 HORE_NR22_P1;
  /*_p14.HAVA*/ DFF9 HAVA_NR22_P2;
  /*_p14.FORE*/ DFF9 FORE_NR22_ADD;
  /*_p14.GATA*/ DFF9 GATA_NR22_V0;
  /*_p14.GUFE*/ DFF9 GUFE_NR22_V1;
  /*_p14.GURA*/ DFF9 GURA_NR22_V2;
  /*_p14.GAGE*/ DFF9 GAGE_NR22_V3;

  //----------

  DFF9 FOFE_NR23_FREQ_00;
  DFF9 FOVA_NR23_FREQ_01;
  DFF9 FEDY_NR23_FREQ_02;
  DFF9 FOME_NR23_FREQ_03;
  DFF9 FORA_NR23_FREQ_04;
  DFF9 GODA_NR23_FREQ_05;
  DFF9 GUMY_NR23_FREQ_06;
  DFF9 GUPU_NR23_FREQ_07;

  //----------

  DFF9 JEFU_NR24_FREQ_08;
  DFF9 JANY_NR24_FREQ_09;
  DFF9 JUPY_NR24_FREQ_10;

  //----------

  /*_p16.KOGA*/ DFF9 KOGA_NR33_FREQ00;
  /*_p16.JOVY*/ DFF9 JOVY_NR33_FREQ01;
  /*_p16.JAXA*/ DFF9 JAXA_NR33_FREQ02;
  /*_p16.JEFE*/ DFF9 JEFE_NR33_FREQ03;
  /*_p16.JYPO*/ DFF9 JYPO_NR33_FREQ04;
  /*_p16.JOVE*/ DFF9 JOVE_NR33_FREQ05;
  /*_p16.KANA*/ DFF9 KANA_NR33_FREQ06;
  /*_p16.KOGU*/ DFF9 KOGU_NR33_FREQ07;

  //----------

  /*_p16.JEMO*/ DFF9 JEMO_NR34_FREQ08;
  /*_p16.JETY*/ DFF9 JETY_NR34_FREQ09;
  /*_p16.JACY*/ DFF9 JACY_NR34_FREQ10;
  /*_p16.HOTO*/ DFF9 HOTO_NR34_LENEN;
  /*_p16.GAVU*/ DFF9 GAVU_NR34_TRIG;

  //----------

  /*_p19.EMOK*/ DFF9 EMOK_NR42_ENV_TIMER0;
  /*_p19.ETYJ*/ DFF9 ETYJ_NR42_ENV_TIMER1;
  /*_p19.EZYK*/ DFF9 EZYK_NR42_ENV_TIMER2;
  /*_p19.GEKY*/ DFF9 GEKY_NR42_ENV_DIR;
  /*_p19.GARU*/ DFF9 GARU_NR42_ENV0;
  /*_p19.GOKY*/ DFF9 GOKY_NR42_ENV1;
  /*_p19.GOZO*/ DFF9 GOZO_NR42_ENV2;
  /*_p19.GEDU*/ DFF9 GEDU_NR42_ENV3;

  //----------

  /*_p19.JARE*/ DFF9 JARE_NR43_DIV0;
  /*_p19.JERO*/ DFF9 JERO_NR43_DIV1;
  /*_p19.JAKY*/ DFF9 JAKY_NR43_DIV2;
  /*_p19.JAMY*/ DFF9 JAMY_NR43_MODE;
  /*_p19.FETA*/ DFF9 FETA_NR43_FREQ0;
  /*_p19.FYTO*/ DFF9 FYTO_NR43_FREQ1;
  /*_p19.GOGO*/ DFF9 GOGO_NR43_FREQ2;
  /*_p19.GAFO*/ DFF9 GAFO_NR43_FREQ3;

  //----------
  // FF24 NR50
  
  /*_p09.APEG*/ DFF9 APEG_NR50_VOL_L0;
  /*_p09.BYGA*/ DFF9 BYGA_NR50_VOL_L1;
  /*_p09.AGER*/ DFF9 AGER_NR50_VOL_L2;
  /*_p09.APOS*/ DFF9 APOS_NR50_VIN_TO_L;
  /*_p09.BYRE*/ DFF9 BYRE_NR50_VOL_R0;
  /*_p09.BUMO*/ DFF9 BUMO_NR50_VOL_R1;
  /*_p09.COZU*/ DFF9 COZU_NR50_VOL_R2;
  /*_p09.BEDU*/ DFF9 BEDU_NR50_VIN_TO_R;

  //----------
  // FF25 NR51

  /*_p09.ANEV*/ DFF9 ANEV_NR51_D0; // these are mixer control bits
  /*_p09.BOGU*/ DFF9 BOGU_NR51_D1;
  /*_p09.BAFO*/ DFF9 BAFO_NR51_D2;
  /*_p09.ATUF*/ DFF9 ATUF_NR51_D3;
  /*_p09.BUME*/ DFF9 BUME_NR51_D4;
  /*_p09.BOFA*/ DFF9 BOFA_NR51_D5;
  /*_p09.BEFO*/ DFF9 BEFO_NR51_D6;
  /*_p09.BEPU*/ DFF9 BEPU_NR51_D7;

  //----------
  // FF26 NR52

  // DBG_APUn polarity?
  /*_p09.FERO*/ DFF9  FERO_NR52_DBG_APUn;     // secret debug bit
  /*_p09.BOWY*/ DFF17 BOWY_NR52_DBG_SWEEP;    // secret debug bit
  /*_p09.HADA*/ DFF17 HADA_NR52_ALL_SOUND_ON; //FF26_7

  //========================================
  //             CHANNEL 2
  //========================================
  DFF20 JORE_CH2_ENV_DELAY;
  DFF20 JONA_CH2_ENV_DELAY;
  DFF20 JEVY_CH2_ENV_DELAY;
  DFF17 JOPA_CH2_ENV_TICK;

  DFF20 DONE_CH2_FREQ_00;
  DFF20 DYNU_CH2_FREQ_01;
  DFF20 EZOF_CH2_FREQ_02;
  DFF20 CYVO_CH2_FREQ_03;
  DFF20 FUXO_CH2_FREQ_04;
  DFF20 GANO_CH2_FREQ_05;
  DFF20 GOCA_CH2_FREQ_06;
  DFF20 GANE_CH2_FREQ_07;
  DFF20 HEVY_CH2_FREQ_08;
  DFF20 HEPU_CH2_FREQ_09;
  DFF20 HERO_CH2_FREQ_10;

  DFF17 DOME_CH2_OUT;

  DFF17 ELOX_CH2_TRIG;
  DFF17 CAZA_CH2_TRIG;
  DFF9 EMER_NR24_LEN;
  DFF17 DOPE_CH2_TRIG;
  DFF9 ETAP_NR24_TRIG;
  DFF17 DORY_CH2_TRIG;
  DFF17 GYKO_CLK;
  /*#p15.CANO*/ DFF17 CANO_00;
  /*#p15.CAGY*/ DFF13 CAGY_01;
  /*#p15.DYVE*/ DFF13 DYVE_02;
  NandLatch BUTA_FREQ_GATEp;
  DFF20 FENA_CH2_VOL3;
  DFF20 FOMY_CH2_VOL2;
  DFF20 FETE_CH2_VOL1;
  DFF20 FENO_CH2_VOL0;
  DFF17 HEPO;
  NorLatch JEME;

  DFF17 JYNA_CLK_64;
  /*_p15.CYRE*/ DFF17 CYRE;

  //========================================
  //             CHANNEL 3
  //========================================

  /*_p16.GOFY*/ NorLatch GOFY;
  NorLatch FOZU;


  /*_p16.GUXE*/ DFF9 GUXE_CH3_AMP_ENn;

  /*_p18.GEVO*/ DFF20 GEVO_CH3_LEN0;
  /*_p18.FORY*/ DFF20 FORY_CH3_LEN1;
  /*_p18.GATU*/ DFF20 GATU_CH3_LEN2;
  /*_p18.GAPO*/ DFF20 GAPO_CH3_LEN3;
  /*_p18.GEMO*/ DFF20 GEMO_CH3_LEN4;
  /*_p18.FORO*/ DFF20 FORO_CH3_LEN5;
  /*_p18.FAVE*/ DFF20 FAVE_CH3_LEN6;
  /*_p18.FYRU*/ DFF20 FYRU_CH3_LEN7;  

  /*_p18.FEXU*/ DFF17 FEXU_LEN_DONE;

  /*_p16.HUKY*/ DFF9 HUKY_NR32_VOL0;
  /*_p16.HODY*/ DFF9 HODY_NR32_VOL1;

  /*_p16.GARA*/ DFF17 GARA;
  /*_p16.GYTA*/ DFF17 GYTA;
  /*_p16.GYRA*/ DFF17 GYRA;

  /*_p18.KUTU*/ DFF20 KUTU_FREQ_00;
  /*_p18.KUPE*/ DFF20 KUPE_FREQ_01;
  /*_p18.KUNU*/ DFF20 KUNU_FREQ_02;
  /*_p18.KEMU*/ DFF20 KEMU_FREQ_03;
  /*_p18.KYGU*/ DFF20 KYGU_FREQ_04;
  /*_p18.KEPA*/ DFF20 KEPA_FREQ_05;
  /*_p18.KAFO*/ DFF20 KAFO_FREQ_06;
  /*_p18.KENO*/ DFF20 KENO_FREQ_07;
  /*_p18.KEJU*/ DFF20 KEJU_FREQ_08;
  /*_p18.KEZA*/ DFF20 KEZA_FREQ_09;
  /*_p18.JAPU*/ DFF20 JAPU_FREQ_10;

  /*_p18.HUNO*/ DFF17 HUNO_WAVE_CLKo;
  /*_p18.EFAR*/ DFF17 EFAR_WAVE_IDX0;
  /*_p18.ERUS*/ DFF17 ERUS_WAVE_IDX1;
  /*_p18.EFUZ*/ DFF17 EFUZ_WAVE_IDX2;
  /*_p18.EXEL*/ DFF17 EXEL_WAVE_IDX3;
  /*_p18.EFAL*/ DFF17 EFAL_WAVE_IDX4;
  /*_p18.FETY*/ DFF17 FETY_WAVE_LOOP;

  /*_p17.CYFO*/ DFF9 CYFO_SAMPLE_0;
  /*_p17.CESY*/ DFF9 CESY_SAMPLE_1;
  /*_p17.BUDY*/ DFF9 BUDY_SAMPLE_2;
  /*_p17.BEGU*/ DFF9 BEGU_SAMPLE_3;
  /*_p17.CUVO*/ DFF9 CUVO_SAMPLE_4;
  /*_p17.CEVO*/ DFF9 CEVO_SAMPLE_5;
  /*_p17.BORA*/ DFF9 BORA_SAMPLE_6;
  /*_p17.BEPA*/ DFF9 BEPA_SAMPLE_7;

  /*_p16.FOBA*/ DFF17 FOBA_CH3_TRIG;
  NandLatch GUGU_FREQ_CLK_STOP;

  // This is a pulse generator for wave ram control line 2/3
  /*_p17.BUSA*/ DFF17 BUSA;
  /*_p17.BANO*/ DFF17 BANO;
  /*_p17.AZUS*/ DFF17 AZUS;
  /*_p17.AZET*/ DFF17 AZET;

  //========================================
  //             CHANNEL 4
  //========================================

  /*_p20.GONE*/ DFF17 GONE_CH4_TRIG;
  /*_p20.GORA*/ DFF17 GORA_CH4_TRIG;
  /*_p20.GATY*/ DFF17 GATY_CH4_TRIG;
  /*_p19.FUGO*/ DFF17 FUGO_CH4_LEN_DONE;

  /*#p19.DANO*/ DFF20 DANO_NR41_LEN0;
  /*#p19.FAVY*/ DFF20 FAVY_NR41_LEN1;
  /*#p19.DENA*/ DFF20 DENA_NR41_LEN2;
  /*#p19.CEDO*/ DFF20 CEDO_NR41_LEN3;
  /*#p19.FYLO*/ DFF20 FYLO_NR41_LEN4;
  /*_p19.EDOP*/ DFF20 EDOP_NR41_LEN5;

  /*#p19.CUNY*/ DFF9 CUNY_NR44_LEN_EN;
  /*#p19.HOGA*/ DFF9 HOGA_NR44_TRIG;
  /*#p20.GYSU*/ DFF17 GYSU_CH4_TRIG;

  /*#p20.HAZO*/ NorLatch HAZO;
  /*#p20.JERY*/ NandLatch JERY_DIV_GATE;
  /*#p20.JYCO*/ DFF20 JYCO_DIV0;
  /*#p20.JYRE*/ DFF20 JYRE_DIV1;
  /*#p20.JYFU*/ DFF20 JYFU_DIV2;
  /*#p20.GARY*/ DFF17 GARY;

  /*_p20.CEXO*/ DFF17 CEXO_FREQ_00;
  /*_p20.DEKO*/ DFF17 DEKO_FREQ_01;
  /*_p20.EZEF*/ DFF17 EZEF_FREQ_02;
  /*_p20.EPOR*/ DFF17 EPOR_FREQ_03;
  /*_p20.DURE*/ DFF17 DURE_FREQ_04;
  /*_p20.DALE*/ DFF17 DALE_FREQ_05;
  /*_p20.DOKE*/ DFF17 DOKE_FREQ_06;
  /*_p20.DEMO*/ DFF17 DEMO_FREQ_07;
  /*_p20.DOSE*/ DFF17 DOSE_FREQ_08;
  /*_p20.DETE*/ DFF17 DETE_FREQ_09;
  /*_p20.ERUT*/ DFF17 ERUT_FREQ_10;
  /*_p20.DOTA*/ DFF17 DOTA_FREQ_11;
  /*_p20.DERE*/ DFF17 DERE_FREQ_12;
  /*_p20.ESEP*/ DFF17 ESEP_FREQ_13;

  /*_p20.JOTO*/ DFF17 JOTO_LFSR_00;
  /*_p20.KOMU*/ DFF17 KOMU_LFSR_01;
  /*_p20.KETU*/ DFF17 KETU_LFSR_02;
  /*_p20.KUTA*/ DFF17 KUTA_LFSR_03;
  /*_p20.KUZY*/ DFF17 KUZY_LFSR_04;
  /*_p20.KYWY*/ DFF17 KYWY_LFSR_05;
  /*_p20.JAJU*/ DFF17 JAJU_LFSR_06;
  /*_p20.HAPE*/ DFF17 HAPE_LFSR_07;
  /*_p20.JUXE*/ DFF17 JUXE_LFSR_08;
  /*_p20.JEPE*/ DFF17 JEPE_LFSR_09;
  /*_p20.JAVO*/ DFF17 JAVO_LFSR_10;
  /*_p20.HEPA*/ DFF17 HEPA_LFSR_11;
  /*_p20.HORY*/ DFF17 HORY_LFSR_12;
  /*_p20.HENO*/ DFF17 HENO_LFSR_13;
  /*_p20.HYRO*/ DFF17 HYRO_LFSR_14;
  /*_p20.HEZU*/ DFF17 HEZU_LFSR_15;

  /*#p20.ABEL*/ DFF17 ABEL_CLK_64;
  /*#p20.CUNA*/ DFF20 CUNA_ENV_TIMER0;
  /*#p20.COFE*/ DFF20 COFE_ENV_TIMER1;
  /*#p20.DOGO*/ DFF20 DOGO_ENV_TIMER2;

  /*#p20.FOSY*/ DFF17 FOSY_ENV_PULSE;
  /*#p20.FYNO*/ DFF17 FYNO_ENV_STOP;

  /*#p20.FEKO*/ DFF20 FEKO_CH4_VOL0;
  /*#p20.FATY*/ DFF20 FATY_CH4_VOL1;
  /*#p20.FERU*/ DFF20 FERU_CH4_VOL2;
  /*#p20.FYRO*/ DFF20 FYRO_CH4_VOL3;
  /*#p20.EROX*/ NorLatch EROX_ENV_CLK2;

  void tick();
};
#pragma once
#include "regs.h"

//-----------------------------------------------------------------------------

inline wire not1(wire a) { return ~a; }

inline wire and2(wire a, wire b) { return a & b; }
inline wire and3(wire a, wire b, wire c) { return  (a & b & c); }

inline wire and4(wire a, wire b, wire c, wire d) { return  (a & b & c & d); }
inline wire and5(wire a, wire b, wire c, wire d, wire e) { return  (a & b & c & d & e); }
inline wire and6(wire a, wire b, wire c, wire d, wire e, wire f) { return  (a & b & c & d & e & f); }
inline wire and7(wire a, wire b, wire c, wire d, wire e, wire f, wire g) { return  (a & b & c & d & e & f & g); }

inline wire or2(wire a, wire b) { return a | b; }
inline wire or3(wire a, wire b, wire c) { return  (a | b | c); }
inline wire or4(wire a, wire b, wire c, wire d) { return  (a | b | c | d); }
inline wire or5(wire a, wire b, wire c, wire d, wire e) { return  (a | b | c | d | e); }
inline wire or6(wire a, wire b, wire c, wire d, wire e, wire f) { return a | b | c | d | e | f; }

// XOR2_01 >> D
// XOR2_02 << A
// XOR2_03 << B
// XOR3_04 --
// XOR3_05 --
// XOR3_06 --

inline wire xor2(wire a, wire b) { return a ^ b; }

inline wire xnor2(wire a, wire b) { return ~(a ^ b); }

inline wire nor2(wire a, wire b) { return ~(a | b); }
inline wire nor3(wire a, wire b, wire c) { return ~(a | b | c); }
inline wire nor4(wire a, wire b, wire c, wire d) { return ~(a | b | c | d); }
inline wire nor5(wire a, wire b, wire c, wire d, wire e) { return ~(a | b | c | d | e); }
inline wire nor6(wire a, wire b, wire c, wire d, wire e, wire f) { return ~(a | b | c | d | e | f); }
inline wire nor8(wire a, wire b, wire c, wire d, wire e, wire f, wire g, wire h) { return ~(a | b | c | d | e | f | g | h); }

inline wire nand2(wire a, wire b) { return ~(a & b); }
inline wire nand3(wire a, wire b, wire c) { return ~(a & b & c); }
inline wire nand4(wire a, wire b, wire c, wire d) { return ~(a & b & c & d); }
inline wire nand5(wire a, wire b, wire c, wire d, wire e) { return ~(a & b & c & d & e); }
inline wire nand6(wire a, wire b, wire c, wire d, wire e, wire f) { return ~(a & b & c & d & e & f); }
inline wire nand7(wire a, wire b, wire c, wire d, wire e, wire f, wire g) { return ~(a & b & c & d & e & f & g); }

inline wire and_or3(wire a, wire b, wire c) { return (a & b) | c; }
inline wire or_and3(wire a, wire b, wire c) { return (a | b) & c; }

inline wire not_or_and3(wire a, wire b, wire c) { return ~or_and3(a, b, c); }

//-----------------------------------------------------------------------------

// Six-rung mux cells are _non_inverting_. m = 1 selects input A
inline wire mux2p(wire m, wire a, wire b) {
  return bit0(m) ? a : b;
}

// Five-rung mux cells are _inverting_. m = 1 selects input A
inline wire mux2n(wire m, wire a, wire b) {
  return ~(bit0(m) ? a : b);
}

inline wire amux2(wire a0, wire b0, wire a1, wire b1) {
  return (b0 & a0) | (b1 & a1);
}

inline wire amux3(wire a0, wire b0, wire a1, wire b1, wire a2, wire b2) {
  return (b0 & a0) | (b1 & a1) | (b2 & a2);
}

inline wire amux4(wire a0, wire b0, wire a1, wire b1, wire a2, wire b2, wire a3, wire b3) {
  return (b0 & a0) | (b1 & a1) | (b2 & a2) | (b3 & a3);
}

inline wire amux6(wire a0, wire b0, wire a1, wire b1, wire a2, wire b2, wire a3, wire b3, wire a4, wire b4, wire a5, wire b5) {
  return (b0 & a0) | (b1 & a1) | (b2 & a2) | (b3 & a3) | (b4 & a4) | (b5 & a5);
}

//-----------------------------------------------------------------------------
#include "metron_tools.h"

typedef logic<16> sample_t;

/*

#pragma warning(push)
#pragma warning(disable:4201)

#pragma pack(push, 1)
struct Req {
  uint16_t addr = 0;
  union {
    struct {
      uint8_t data_lo;
      uint8_t data_hi;
    };
    uint16_t data = 0;
  };
  uint8_t  read = 0;
  uint8_t  write = 0;
  uint16_t pad1 = 0;

  operator bool() const {
    return read || write;
  }
};
#pragma pack(pop)

static_assert(sizeof(Req) == 8, "Req size != 8");

struct Ack {
  uint16_t addr = 0;
  union {
    struct {
      uint8_t data_lo;
      uint8_t data_hi;
    };
    uint16_t data = 0;
  };
  uint8_t  read = 0;
  uint8_t  pad1 = 0;
  uint16_t pad2 = 0;
};

static_assert(sizeof(Ack) == 8, "Ack size != 8");

#pragma warning(pop)
 
struct Req {
  logic<16> addr;
  logic<8> data_lo;
  logic<8> data_hi;
  logic<8> read;
  logic<8> write;
};

struct Ack {
  logic<16> addr;
  //logic<1> read;
  //logic<1> write;
  logic<8> read;
  logic<8> write;

  logic<8> data_lo;
  logic<8> data_hi;
};
*/

//-----------------------------------------------------------------------------

class MetroBoySPU {
public:

  logic<16> out_r;
  logic<16> out_l;

  logic<8> ack_data;
  logic<1> ack_valid;

  void tock_ack(logic<16> addr) {
    ack_data = 0;
    ack_valid = 0;

    if (addr >= 0xFF30 && addr <= 0xFF3F) {
      // wavetable
      ack_data = s3_wave[addr & 0xF];
    }
    else if (addr >= 0xFF10 && addr <= 0xFF26) {
      switch (addr) {
        case 0xFF10: ack_data = nr10 | 0x80; break;
        case 0xFF11: ack_data = nr11 | 0x3F; break;
        case 0xFF12: ack_data = nr12 | 0x00; break;
        case 0xFF13: ack_data = nr13 | 0xFF; break;
        case 0xFF14: ack_data = nr14 | 0xBF; break;

        case 0xFF15: ack_data = nr20 | 0xFF; break;
        case 0xFF16: ack_data = nr21 | 0x3F; break;
        case 0xFF17: ack_data = nr22 | 0x00; break;
        case 0xFF18: ack_data = nr23 | 0xFF; break;
        case 0xFF19: ack_data = nr24 | 0xBF; break;

        case 0xFF1A: ack_data = nr30 | 0x7F; break;
        case 0xFF1B: ack_data = nr31 | 0xFF; break;
        case 0xFF1C: ack_data = nr32 | 0x9F; break;
        case 0xFF1D: ack_data = nr33 | 0xFF; break;
        case 0xFF1E: ack_data = nr34 | 0xBF; break;

        case 0xFF1F: ack_data = nr40 | 0xFF; break;
        case 0xFF20: ack_data = nr41 | 0xFF; break;
        case 0xFF21: ack_data = nr42 | 0x00; break;
        case 0xFF22: ack_data = nr43 | 0x00; break;
        case 0xFF23: ack_data = nr44 | 0xBF; break;

        case 0xFF24: ack_data = nr50 | 0x00; break;
        case 0xFF25: ack_data = nr51 | 0x00; break;

        case 0xFF26: {
          logic<8> bus_out_ = (nr52 & 0x80) | 0x70;
          if (s1_enable) bus_out_ = bus_out_ | b8(0b00000001);
          if (s2_enable) bus_out_ = bus_out_ | b8(0b00000010);
          if (s3_enable) bus_out_ = bus_out_ | b8(0b00000100);
          if (s4_enable) bus_out_ = bus_out_ | b8(0b00001000);
          ack_data = bus_out_;
          break;
        }
      }
    }

  }

public:

  void tock_out() {
    out_l = 0;
    out_r = 0;

    //----------
    // mixer & master volume

    logic<16> out_r_ = 0;
    logic<16> out_l_ = 0;

    if (nr51 & 0b00000001) out_r_ = out_r_ + s1_out;
    if (nr51 & 0b00000010) out_r_ = out_r_ + s2_out;
    if (nr51 & 0b00000100) out_r_ = out_r_ + s3_out;
    if (nr51 & 0b00001000) out_r_ = out_r_ + s4_out;
    if (nr51 & 0b00010000) out_l_ = out_l_ + s1_out;
    if (nr51 & 0b00100000) out_l_ = out_l_ + s2_out;
    if (nr51 & 0b01000000) out_l_ = out_l_ + s3_out;
    if (nr51 & 0b10000000) out_l_ = out_l_ + s4_out;

    logic<4> volume_r = ((nr50 & 0b00000111) >> 0) + 1;
    logic<4> volume_l = ((nr50 & 0b01110000) >> 4) + 1;

    out_r = out_r_ * volume_r;
    out_l = out_l_ * volume_l;
  }

  void tick(logic<1> reset, logic<16> addr, logic<8> data, logic<1> we) {
    if (reset) {
      nr10 = 0x80;
      nr11 = 0xBF;
      nr12 = 0xF3;
      nr13 = 0xFF;
      nr14 = 0xBF;

      nr20 = 0x00;
      nr21 = 0x3F;
      nr22 = 0x00;
      nr23 = 0xFF;
      nr24 = 0xBF;

      nr30 = 0x7F;
      nr31 = 0xFF;
      nr32 = 0x9F;
      nr33 = 0xFF;
      nr34 = 0xBF;

      nr40 = 0x80;
      nr41 = 0xFF;
      nr42 = 0x00;
      nr43 = 0x00;
      nr44 = 0xBF;

      nr50 = 0x77;
      nr51 = 0xF3;
      nr52 = 0xF1;

      for (int i = 0; i < 16; i++) {
        s3_wave[i] = 0;
      }

      s4_lfsr = 0x7FFF;

      spu_clock = 0;

      s1_enable = 1;
      s2_enable = 0;
      s3_enable = 0;
      s4_enable = 0;

      s1_sweep_clock = 0;
      s1_sweep_freq = 0;


      s1_duration = 0;
      s2_duration = 0;
      s3_duration = 0;

      s4_duration = 0;
      s1_env_clock = 0;
      s2_env_clock = 0;
      s4_env_clock = 0;

      s1_env_volume = 0;
      s2_env_volume = 0;
      s4_env_volume = 0;

      s1_phase_clock = 0;
      s2_phase_clock = 0;
      s3_phase_clock = 0;
      s4_phase_clock = 0;

      s1_phase = 0;
      s2_phase = 0;
      s3_phase = 0;

      s1_out = 0;
      s2_out = 0;
      s3_out = 0;
      s4_out = 0;
    }
    else {
      logic<1> sound_on = (nr52 & 0x80);
      logic<16> spu_clock_ = (spu_clock + 1) & 0x3FFF;
      logic<16> clock_flip = (~spu_clock) & spu_clock_;

      logic<1> sweep_tick =  (spu_clock_ & 0b01111111111111) == 0b01000000000000;
      logic<1> length_tick = (spu_clock_ & 0b00111111111111) == 0b00000000000000;
      logic<1> env_tick =    (spu_clock_ & 0b11111111111111) == 0b11100000000000;

      //----------
      // output

      s1_out = 0;
      s2_out = 0;
      s3_out = 0;
      s4_out = 0;

      if (s1_enable) {
        logic<8> s1_volume = (nr12 & 0x08) ? b8(s1_env_volume) : b8(15 ^ s1_env_volume);
        logic<8> s1_duty = (nr11 & 0b11000000) >> 6;
        s1_duty = s1_duty ? s1_duty * 2 : 1;
        logic<8> s1_sample = (s1_phase < s1_duty) ? b8(s1_volume) : b8(0);
        s1_out = s1_sample;
      }

      if (s2_enable) {
        logic<8> s2_volume = (nr22 & 0x08) ? b8(s2_env_volume) : b8(15 ^ s2_env_volume);
        logic<8> s2_duty = (nr21 & 0b11000000) >> 6;
        s2_duty = s2_duty ? s2_duty * 2 : 1;
        logic<8> s2_sample = (s2_phase < s2_duty) ? b8(s2_volume) : b8(0);
        s2_out = s2_sample;
      }

      logic<1> s3_power = (nr30 & 0b10000000);
      if (s3_enable && s3_power) {
        logic<8> s3_volume_shift = 0;
        switch ((nr32 & 0b01100000) >> 5) {
          case 0: s3_volume_shift = 4; break;
          case 1: s3_volume_shift = 0; break;
          case 2: s3_volume_shift = 1; break;
          case 3: s3_volume_shift = 2; break;
        }
        logic<8> s3_sample = s3_wave[s3_phase >> 1];
        s3_sample = (s3_phase & 1) ? b8(s3_sample & 0xF) : b8(s3_sample >> 4);
        s3_sample = s3_sample >> s3_volume_shift;
        s3_out = s3_sample;
      }

      if (s4_enable) {
        logic<8> s4_volume = (nr42 & 0x08) ? b8(s4_env_volume) : b8(15 ^ s4_env_volume);
        logic<8> s4_sample = (s4_lfsr & 1) ? b8(s4_volume) : b8(0);
        s4_out = s4_sample;
      }

      //----------
      // s1 clock

      if (!s1_phase_clock) {
        logic<8> s1_sweep_period = (nr10 & 0b01110000) >> 4;
        logic<16> s1_freq = ((nr14 << 8) | nr13) & 0x07FF;

        s1_phase_clock = 2047 ^ (s1_sweep_period ? s1_sweep_freq : s1_freq);
        s1_phase = (s1_phase + 1) & 7;
      }
      else {
        s1_phase_clock = s1_phase_clock - 1;
      }

      //----------
      // s2 clock

      if (!s2_phase_clock) {
        logic<16> s2_freq = ((nr24 << 8) | nr23) & 0x07FF;

        s2_phase_clock = 2047 ^ s2_freq;
        s2_phase = (s2_phase + 1) & 7;
      }
      else {
        s2_phase_clock = s2_phase_clock - 1;
      }

      //----------
      // s3 clock - we run this twice because this is ticking at 1 mhz

      logic<16> s3_phase_clock_ = s3_phase_clock;
      logic<8> s3_phase_ = s3_phase;

      if (!s3_phase_clock_) {
        logic<16> s3_freq = ((nr34 << 8) | nr33) & 0x07FF;

        s3_phase_clock_ = 2047 ^ s3_freq;
        s3_phase_ = (s3_phase_ + 1) & 31;
      }
      else {
        s3_phase_clock_ = s3_phase_clock_ - 1;
      }

      if (!s3_phase_clock_) {
        logic<16> s3_freq = ((nr34 << 8) | nr33) & 0x07FF;

        s3_phase_clock_ = 2047 ^ s3_freq;
        s3_phase_ = (s3_phase_ + 1) & 31;
      }
      else {
        s3_phase_clock_ = s3_phase_clock_ - 1;
      }

      s3_phase_clock = s3_phase_clock_;
      s3_phase = s3_phase_;

      //----------
      // s4 clock

      if (!s4_phase_clock) {
        logic<1> s4_lfsr_mode = (nr43 & 0b00001000) >> 3;
        logic<8> s4_phase_period = (nr43 & 0b00000111) ? (nr43 & 0b00000111) * 2 : 1;

        s4_phase_clock = s4_phase_period;
        logic<1> lfsr_bit = (s4_lfsr ^ (s4_lfsr >> 1)) & 1;
        s4_phase_clock = s4_phase_period;
        if (s4_lfsr_mode) {
          s4_lfsr = ((s4_lfsr >> 1) & 0b0111111111011111) | (lfsr_bit << 5);
        }
        else {
          s4_lfsr = ((s4_lfsr >> 1) & 0b0011111111111111) | (lfsr_bit << 14);
        }
      }
      else {
        logic<8> s4_clock_shift = (nr43 & 0b11110000) >> 4;
        s4_phase_clock = s4_phase_clock - ((clock_flip >> s4_clock_shift) & 1);
      }

      //----------
      // sweep

      if (sweep_tick) {
        logic<8> s1_sweep_period = (nr10 & 0b01110000) >> 4;
        logic<8> s1_sweep_shift = (nr10 & 0b00000111) >> 0;
        logic<1> s1_sweep_dir = (nr10 & 0b00001000) >> 3;

        if (s1_sweep_period && s1_sweep_shift) {
          if (s1_sweep_clock) {
            s1_sweep_clock = s1_sweep_clock - 1;
          }
          else {
            logic<16> delta = s1_sweep_freq >> s1_sweep_shift;
            logic<16> new_freq = s1_sweep_freq + (s1_sweep_dir ? -delta : +delta);
            s1_sweep_clock = s1_sweep_period;
            if (new_freq > 2047) {
              s1_enable = 0;
            }
            else {
              s1_sweep_freq = new_freq;
            }
          }
        }
      }

      //----------
      // length

      if (length_tick) {
        logic<1> s1_length_enable = (nr14 & 0b01000000) >> 6;
        logic<1> s2_length_enable = (nr24 & 0b01000000) >> 6;
        logic<1> s3_length_enable = (nr34 & 0b01000000) >> 6;
        logic<1> s4_length_enable = (nr44 & 0b01000000) >> 6;
        logic<8> s1_duration_ = s1_duration;
        logic<8> s2_duration_ = s2_duration;
        logic<16> s3_duration_ = s3_duration;
        logic<8> s4_duration_ = s4_duration;

        if (s1_length_enable && s1_duration_) s1_duration_ = s1_duration_ - 1;
        if (s2_length_enable && s2_duration_) s2_duration_ = s2_duration_ - 1;
        if (s3_length_enable && s3_duration_) s3_duration_ = s3_duration_ - 1;
        if (s4_length_enable && s4_duration_) s4_duration_ = s4_duration_ - 1;

        if (s1_length_enable && s1_duration_ == 0) s1_enable = 0;
        if (s2_length_enable && s2_duration_ == 0) s2_enable = 0;
        if (s3_length_enable && s3_duration_ == 0) s3_enable = 0;
        if (s4_length_enable && s4_duration_ == 0) s4_enable = 0;

        s1_duration = s1_duration_;
        s2_duration = s2_duration_;
        s3_duration = s3_duration_;
        s4_duration = s4_duration_;
      }

      //----------
      // env

      if (env_tick) {
        logic<1> s1_env_dir = (nr12 & 0b00001000) >> 3;
        logic<1> s2_env_dir = (nr22 & 0b00001000) >> 3;
        logic<1> s4_env_dir = (nr42 & 0b00001000) >> 3;

        logic<8> s1_env_period = (nr12 & 0b00000111) >> 0;
        logic<8> s2_env_period = (nr22 & 0b00000111) >> 0;
        logic<8> s4_env_period = (nr42 & 0b00000111) >> 0;

        if (s1_env_period) {
          if (s1_env_clock) {
            s1_env_clock = s1_env_clock - 1;
          }
          else {
            s1_env_clock = s1_env_period;
            if (s1_env_volume < 15) s1_env_volume = s1_env_volume + 1;
          }
        }

        if (s2_env_period) {
          if (s2_env_clock) {
            s2_env_clock = s2_env_clock - 1;
          }
          else {
            s2_env_clock = s2_env_period;
            if (s2_env_volume < 15) s2_env_volume = s2_env_volume + 1;
          }
        }

        if (s4_env_period) {
          if (s4_env_clock) {
            s4_env_clock = s4_env_clock - 1;
          }
          else {
            s4_env_clock = s4_env_period;
            if (s4_env_volume < 15) s4_env_volume = s4_env_volume + 1;
          }
        }
      }

      spu_clock = spu_clock_;

      //----------
      // Wavetable writes

      if (we && addr >= 0xFF30 && addr <= 0xFF3F) {
        s3_wave[addr & 0xF] = data;
      }

      //----------
      // Triggers

      logic<1> s1_trigger_ = we && addr == 0xFF14 && (data & 0x80);
      logic<1> s2_trigger_ = we && addr == 0xFF19 && (data & 0x80);
      logic<1> s3_trigger_ = we && addr == 0xFF1E && (data & 0x80);
      logic<1> s4_trigger_ = we && addr == 0xFF23 && (data & 0x80);

      if (s1_trigger_) {
        logic<8> s1_sweep_period = (nr10 & 0b01110000) >> 4;
        logic<8> s1_length = 64 - (nr11 & 0b00111111);
        logic<8> s1_start_volume = (nr12 & 0b11110000) >> 4;
        logic<8> s1_env_period = (nr12 & 0b00000111) >> 0;
        logic<16> s1_freq = ((nr14 << 8) | nr13) & 0x07FF;

        s1_enable = (nr12 & 0xF8) != 0;
        s1_duration = s1_length;
        s1_sweep_clock = s1_sweep_period;
        s1_sweep_freq = s1_freq;

        s1_env_volume = (nr12 & 0x08) ? b8(s1_start_volume) : b8(15 ^ s1_start_volume);
        s1_env_clock = s1_env_period;

        s1_phase_clock = 2047 ^ s1_freq;
        s1_phase = 0;
      }

      if (s2_trigger_) {
        logic<8> s2_length = 64 - (nr21 & 0b00111111);
        logic<8> s2_start_volume = (nr22 & 0b11110000) >> 4;
        logic<8> s2_env_period = (nr22 & 0b00000111) >> 0;
        logic<16> s2_freq = ((nr24 << 8) | nr23) & 0x07FF;

        s2_enable = (nr22 & 0xF8) != 0;
        s2_duration = s2_length;

        s2_env_volume = (nr22 & 0x08) ? b8(s2_start_volume) : b8(15 ^ s2_start_volume);
        s2_env_clock = s2_env_period;

        s2_phase_clock = 2047 ^ s2_freq;
        s2_phase = 0;
      }

      if (s3_trigger_) {
        logic<16> s3_length = 256 - nr31;
        logic<16> s3_freq = ((nr34 << 8) | nr33) & 0x07FF;

        s3_enable = (nr32 != 0);
        s3_duration = s3_length;
        s3_phase_clock = 2047 ^ s3_freq;
        s3_phase = 0;
      }

      if (s4_trigger_) {
        logic<8> s4_length = 64 - (nr41 & 0b00111111);
        logic<8> s4_start_volume = (nr42 & 0b11110000) >> 4;
        logic<8> s4_env_period = (nr42 & 0b00000111) >> 0;
        logic<8> s4_phase_period = (nr43 & 0b00000111) ? (nr43 & 0b00000111) * 2 : 1;

        s4_enable = (nr42 & 0xF8) != 0;
        s4_duration = s4_length;

        s4_env_volume = (nr42 & 0x08) ? b8(s4_start_volume) : b8(15 ^ s4_start_volume);
        s4_env_clock = s4_env_period;

        s4_phase_clock = s4_phase_period;
        s4_lfsr = 0x7FFF;
      }

      //----------
      // Register writes

      if (we && addr >= 0xFF10 && addr <= 0xFF26) {
        switch (addr) {
          case 0xFF10: nr10 = data | 0b10000000; break;
          case 0xFF11: nr11 = data | 0b00000000; break;
          case 0xFF12: nr12 = data | 0b00000000; break;
          case 0xFF13: nr13 = data | 0b00000000; break;
          case 0xFF14: nr14 = data | 0b00111000; break;
          case 0xFF16: nr21 = data | 0b00000000; break;
          case 0xFF17: nr22 = data | 0b00000000; break;
          case 0xFF18: nr23 = data | 0b00000000; break;
          case 0xFF19: nr24 = data | 0b00111000; break;
          case 0xFF1A: nr30 = data | 0b01111111; break;
          case 0xFF1B: nr31 = data | 0b00000000; break;
          case 0xFF1C: nr32 = data | 0b10011111; break;
          case 0xFF1D: nr33 = data | 0b00000000; break;
          case 0xFF1E: nr34 = data | 0b00111000; break;
          case 0xFF20: nr41 = data | 0b11000000; break;
          case 0xFF21: nr42 = data | 0b00000000; break;
          case 0xFF22: nr43 = data | 0b00000000; break;
          case 0xFF23: nr44 = data | 0b00111111; break;
          case 0xFF24: nr50 = data | 0b00000000; break;
          case 0xFF25: nr51 = data | 0b00000000; break;
          case 0xFF26: nr52 = data | 0b01110000; break;
        }
      }


    }
  }

  //-----------------------------------------------------------------------------

private:

  logic<8> nr10;
  logic<8> nr11;
  logic<8> nr12;
  logic<8> nr13;

  logic<8> nr14;
  logic<8> nr20;
  logic<8> nr21;
  logic<8> nr22;

  logic<8> nr23;
  logic<8> nr24;
  logic<8> nr30;
  logic<8> nr31;

  logic<8> nr32;
  logic<8> nr33;
  logic<8> nr34;
  logic<8> nr40;

  logic<8> nr41;
  logic<8> nr42;
  logic<8> nr43;
  logic<8> nr44;

  logic<8> nr50;
  logic<8> nr51;
  logic<8> nr52;

  logic<8> s3_wave[16];

  logic<16> s4_lfsr;

  logic<16> spu_clock;

  logic<1> s1_enable;
  logic<1> s2_enable;
  logic<1> s3_enable;
  logic<1> s4_enable;

  logic<8> s1_sweep_clock;
  logic<16> s1_sweep_freq;

  logic<8> s1_duration;
  logic<8> s2_duration;
  logic<16> s3_duration;

  logic<8> s4_duration;
  logic<8> s1_env_clock;
  logic<8> s2_env_clock;
  logic<8> s4_env_clock;

  logic<8> s1_env_volume;
  logic<8> s2_env_volume;
  logic<8> s4_env_volume;

  logic<16> s1_phase_clock;
  logic<16> s2_phase_clock;
  logic<16> s3_phase_clock;
  logic<16> s4_phase_clock;

  logic<8> s1_phase;
  logic<8> s2_phase;
  logic<8> s3_phase;

  logic<8> s1_out;
  logic<8> s2_out;
  logic<8> s3_out;
  logic<8> s4_out;
};

/*

  void tick(int phase_total, const Req& req, Ack& ack) {

  }

  //----------
  // glitches n stuff

  if (we && addr == 0xFF12) {
    if ((nr12 & 0x08) && s1_enable) s1_env_volume = (s1_env_volume + 1) & 15;
    if ((data & 0xF8) == 0) s1_enable = 0;
  }

  if (we && addr == 0xFF17) {
    if ((nr22 & 0x08) && s2_enable) s2_env_volume = (s2_env_volume + 1) & 15;
    if ((data & 0xF8) == 0) s2_enable = 0;
  }

  if (we && addr == 0xFF21) {
    if ((nr42 & 0x08) && s4_enable) s4_env_volume = (s4_env_volume + 1) & 15;
    if ((data & 0xF8) == 0) s4_enable = 0;
  }

//-----------------------------------------------------------------------------

void MetroBoySPU::dump(Dumper& d) const {
  d("\002--------------SPU--------------\001\n");

  d("NR10 %s\n", byte_to_bits(nr10));
  d("NR11 %s\n", byte_to_bits(nr11));
  d("NR12 %s\n", byte_to_bits(nr12));
  d("NR13 %s\n", byte_to_bits(nr13));
  d("NR14 %s\n", byte_to_bits(nr14));
  d("NR20 %s\n", byte_to_bits(nr20));
  d("NR21 %s\n", byte_to_bits(nr21));
  d("NR22 %s\n", byte_to_bits(nr22));
  d("NR23 %s\n", byte_to_bits(nr23));
  d("NR24 %s\n", byte_to_bits(nr24));
  d("NR30 %s\n", byte_to_bits(nr30));
  d("NR31 %s\n", byte_to_bits(nr31));
  d("NR32 %s\n", byte_to_bits(nr32));
  d("NR33 %s\n", byte_to_bits(nr33));
  d("NR34 %s\n", byte_to_bits(nr34));
  d("NR40 %s\n", byte_to_bits(nr40));
  d("NR41 %s\n", byte_to_bits(nr41));
  d("NR42 %s\n", byte_to_bits(nr42));
  d("NR43 %s\n", byte_to_bits(nr43));
  d("NR44 %s\n", byte_to_bits(nr44));
  d("NR50 %s\n", byte_to_bits(nr50));
  d("NR51 %s\n", byte_to_bits(nr51));
  d("NR52 %s\n", byte_to_bits(nr52));

  const char* bar = "===============";

  logic<8> s1_volume = (nr12 & 0x08) ? s1_env_volume : 15 ^ s1_env_volume;
  d("s1 vol %s\n", bar + (15 - s1_volume));

  logic<8> s2_volume = (nr22 & 0x08) ? s2_env_volume : 15 ^ s2_env_volume;
  d("s2 vol %s\n", bar + (15 - s2_volume));

  logic<8> s3_volume = 0;
  switch ((nr32 & 0b01100000) >> 5) {
  case 0: s3_volume = 0; break;
  case 1: s3_volume = 15; break;
  case 2: s3_volume = 7; break;
  case 3: s3_volume = 3; break;
  }
  d("s3 vol %s\n", bar + (15 - s3_volume));

  logic<8> s4_volume = (nr42 & 0x08) ? s4_env_volume : 15 ^ s4_env_volume;
  d("s4 vol %s\n", bar + (15 - s4_volume));

  if (0) {
    char buf[33];
    for (int i = 0; i < 16; i++) {
      logic<8> a = (s3_wave[i] & 0x0F) >> 0;
      logic<8> b = (s3_wave[i] & 0xF0) >> 4;

      buf[2 * i + 0] = 'A' + a;
      buf[2 * i + 1] = 'A' + b;
    }

    buf[32] = 0;
    d("[%s]\n", buf);
  }
}

//-----------------------------------------------------------------------------
*/
Same as rvtiny, but synchronous. Not finished yet.
#pragma once
#include "metron_tools.h"

class toplevel {
 public:
  toplevel() {
    pc = 0;
    phase = 0;
    inst = 0;
    regs[0] = b32(0);

    std::string s;
    value_plusargs("text_file=%s", s);
    readmemh(s, text_mem);

    value_plusargs("data_file=%s", s);
    readmemh(s, data_mem);
  }

  void tock(logic<1> reset) { tick(reset); }

  logic<32> o_bus_read_data;
  logic<32> o_bus_address;
  logic<32> o_bus_write_data;
  logic<4> o_bus_byte_enable;
  logic<1> o_bus_read_enable;
  logic<1> o_bus_write_enable;
  logic<32> o_inst;
  logic<32> o_pc;

  //----------------------------------------

 private:
  static const int OP_ALU = 0x33;
  static const int OP_ALUI = 0x13;
  static const int OP_LOAD = 0x03;
  static const int OP_STORE = 0x23;
  static const int OP_BRANCH = 0x63;
  static const int OP_JAL = 0x6F;
  static const int OP_JALR = 0x67;
  static const int OP_LUI = 0x37;
  static const int OP_AUIPC = 0x17;

  void tick(logic<1> reset) {
    if (reset) {
      pc = 0;
      phase = 0;
      inst = 0;
      regs[0] = b32(0);
      o_bus_read_data = 0;
      o_bus_address = 0;
      o_bus_write_data = 0;
      o_bus_byte_enable = 0;
      o_bus_read_enable = 0;
      o_bus_write_enable = 0;
      o_inst = 0;
      o_pc = 0;
    } else {
      if (phase == 0) {
        phase = 1;
        inst = text_mem[b14(pc, 2)];
      } else if (phase == 1) {
        phase = 0;

        logic<7> op = b7(inst, 0);
        logic<5> rd = b5(inst, 7);
        logic<3> f3 = b3(inst, 12);
        logic<5> r1 = b5(inst, 15);
        logic<5> r2 = b5(inst, 20);
        logic<7> f7 = b7(inst, 25);

        o_bus_address = 0;
        o_bus_write_enable = 0;
        o_bus_write_data = 0;

        //----------
        // Metron simulates this a few percent faster if we don't have ALU and
        // ALUI in the same branch, but then we duplicate the big ALU switch...

        if (op == OP_ALU || op == OP_ALUI) {
          logic<32> op_a = regs[r1];
          logic<32> op_b =
              op == OP_ALUI ? cat(dup<21>(inst[31]), b6(inst, 25), b5(inst, 20))
                            : regs[r2];
          logic<32> alu_result;

          switch (f3) {
            case 0:
              alu_result = (op == OP_ALU) && f7[5] ? op_a - op_b : op_a + op_b;
              break;
            case 1:
              alu_result = op_a << b5(op_b);
              break;
            case 2:
              alu_result = signed(op_a) < signed(op_b);
              break;
            case 3:
              alu_result = op_a < op_b;
              break;
            case 4:
              alu_result = op_a ^ op_b;
              break;
            case 5: {
              // FIXME BUG Verilator isn't handling this ternary expression
              // correctly.
              // alu_result = f7[5] ? sra(op_a, b5(op_b)) : b32(op_a >>
              // b5(op_b)); break;
              if (f7[5]) {
                alu_result = sra(op_a, b5(op_b));
              } else {
                alu_result = op_a >> b5(op_b);
              }
              break;
            }
            case 6:
              alu_result = op_a | op_b;
              break;
            case 7:
              alu_result = op_a & op_b;
              break;
          }

          if (rd) regs[rd] = alu_result;
          pc = pc + 4;
        }

        //----------

        else if (op == OP_LOAD) {
          logic<32> imm = cat(dup<21>(inst[31]), b6(inst, 25), b5(inst, 20));
          logic<32> addr = regs[r1] + imm;
          logic<32> rdata = data_mem[b15(addr, 2)] >> (8 * b2(addr));

          switch (f3) {
            case 0:
              rdata = sign_extend<32>(b8(rdata));
              break;
            case 1:
              rdata = sign_extend<32>(b16(rdata));
              break;
            case 4:
              rdata = b8(rdata);
              break;
            case 5:
              rdata = b16(rdata);
              break;
          }

          if (rd) regs[rd] = rdata;
          pc = pc + 4;
        }

        //----------

        else if (op == OP_STORE) {
          logic<32> imm = cat(dup<21>(inst[31]), b6(inst, 25), b5(inst, 7));
          logic<32> addr = regs[r1] + imm;
          logic<32> wdata = regs[r2] << (8 * b2(addr));

          logic<32> mask = 0;
          if (f3 == 0) mask = 0x000000FF << (8 * b2(addr));
          if (f3 == 1) mask = 0x0000FFFF << (8 * b2(addr));
          if (f3 == 2) mask = 0xFFFFFFFF;

          logic<15> phys_addr = b15(addr, 2);
          data_mem[phys_addr] = (data_mem[phys_addr] & ~mask) | (wdata & mask);

          pc = pc + 4;

          o_bus_address = addr;
          o_bus_write_enable = 1;
          o_bus_write_data = regs[r2];
        }

        //----------

        else if (op == OP_BRANCH) {
          logic<32> op_a = regs[r1];
          logic<32> op_b = regs[r2];

          logic<1> take_branch;
          switch (f3) {
            case 0:
              take_branch = op_a == op_b;
              break;
            case 1:
              take_branch = op_a != op_b;
              break;
            case 4:
              take_branch = signed(op_a) < signed(op_b);
              break;
            case 5:
              take_branch = signed(op_a) >= signed(op_b);
              break;
            case 6:
              take_branch = op_a < op_b;
              break;
            case 7:
              take_branch = op_a >= op_b;
              break;
            default:
              take_branch = b1(DONTCARE);
              break;
          }

          if (take_branch) {
            logic<32> imm = cat(dup<20>(inst[31]), inst[7], b6(inst, 25),
                                b4(inst, 8), b1(0));
            pc = pc + imm;
          } else {
            pc = pc + 4;
          }
        }

        //----------

        else if (op == OP_JAL) {
          logic<32> imm = cat(dup<12>(inst[31]), b8(inst, 12), inst[20],
                              b6(inst, 25), b4(inst, 21), b1(0));
          if (rd) regs[rd] = pc + 4;
          pc = pc + imm;
        }

        //----------

        else if (op == OP_JALR) {
          logic<32> rr1 = regs[r1];  // Lol, Metron actually found a bug - gotta
                                     // read r1 before writing
          logic<32> imm = cat(dup<21>(inst[31]), b6(inst, 25), b5(inst, 20));
          if (rd) regs[rd] = pc + 4;
          pc = rr1 + imm;
        }

        //----------

        else if (op == OP_LUI) {
          logic<32> imm = cat(inst[31], b11(inst, 20), b8(inst, 12), b12(0));
          if (rd) regs[rd] = imm;
          pc = pc + 4;
        }

        //----------

        else if (op == OP_AUIPC) {
          logic<32> imm = cat(inst[31], b11(inst, 20), b8(inst, 12), b12(0));
          if (rd) regs[rd] = pc + imm;
          pc = pc + 4;
        }
      }
    }
  }

  logic<32> pc;
  logic<2> phase;
  logic<32> inst;
  logic<32> text_mem[32 * 1024];
  logic<32> data_mem[32 * 1024];
  logic<32> regs[32];
};
A trivial single-file, single-function, single-cycle RISC-V core.

Probably won't synthesize since the ram is asynchronous, but runs at 300+ mhz
in simulation.
#pragma once
#include "metron_tools.h"

class toplevel {
 public:
  toplevel() {
    pc = 0;
    regs[0] = b32(0);

    std::string s;
    value_plusargs("text_file=%s", s);
    readmemh(s, text_mem);

    value_plusargs("data_file=%s", s);
    readmemh(s, data_mem);
  }

  void tock(logic<1> reset) {
    tick(reset);
  }

  logic<32> bus_read_data;
  logic<32> bus_address;
  logic<32> bus_write_data;
  logic<4> bus_byte_enable;
  logic<1> bus_read_enable;
  logic<1> bus_write_enable;
  logic<32> pc;

  //----------------------------------------

 private:
  static const int OP_ALU = 0x33;
  static const int OP_ALUI = 0x13;
  static const int OP_LOAD = 0x03;
  static const int OP_STORE = 0x23;
  static const int OP_BRANCH = 0x63;
  static const int OP_JAL = 0x6F;
  static const int OP_JALR = 0x67;
  static const int OP_LUI = 0x37;
  static const int OP_AUIPC = 0x17;

  void tick(logic<1> reset) {
    if (reset) {
      pc = 0;
      regs[0] = b32(0);
      bus_read_data = 0;
      bus_address = 0;
      bus_write_data = 0;
      bus_byte_enable = 0;
      bus_read_enable = 0;
      bus_write_enable = 0;
    } else {
      logic<32> inst = text_mem[b14(pc, 2)];

      logic<7> op = b7(inst, 0);
      logic<5> rd = b5(inst, 7);
      logic<3> f3 = b3(inst, 12);
      logic<5> r1 = b5(inst, 15);
      logic<5> r2 = b5(inst, 20);
      logic<7> f7 = b7(inst, 25);

      bus_address = 0;
      bus_write_enable = 0;
      bus_write_data = 0;

      //----------
      // Metron simulates this a few percent faster if we don't have ALU and
      // ALUI in the same branch, but then we duplicate the big ALU switch...

      if (op == OP_ALU || op == OP_ALUI) {
        logic<32> op_a = regs[r1];
        logic<32> op_b =
            op == OP_ALUI ? cat(dup<21>(inst[31]), b6(inst, 25), b5(inst, 20))
                          : regs[r2];
        logic<32> alu_result;

        // clang-format off
        switch (f3) {
          case 0: alu_result = (op == OP_ALU) && f7[5] ? op_a - op_b : op_a + op_b; break;
          case 1: alu_result = op_a << b5(op_b); break;
          case 2: alu_result = signed(op_a) < signed(op_b); break;
          case 3: alu_result = op_a < op_b; break;
          case 4: alu_result = op_a ^ op_b; break;
          case 5: {
            // FIXME BUG Verilator isn't handling this ternary expression
            // correctly.
            // alu_result = f7[5] ? sra(op_a, b5(op_b)) : b32(op_a >> b5(op_b));
            // break;
            if (f7[5]) {
              alu_result = sra(op_a, b5(op_b));
            } else {
              alu_result = op_a >> b5(op_b);
            }
            break;
          }
          case 6: alu_result = op_a | op_b; break;
          case 7: alu_result = op_a & op_b; break;
        }
        // clang-format on

        if (rd) regs[rd] = alu_result;
        pc = pc + 4;
      }

      //----------

      else if (op == OP_LOAD) {
        logic<32> imm = cat(dup<21>(inst[31]), b6(inst, 25), b5(inst, 20));
        logic<32> addr = regs[r1] + imm;
        logic<32> data = data_mem[b15(addr, 2)] >> (8 * b2(addr));

        // clang-format off
        switch (f3) {
          case 0: data = sign_extend<32>(b8(data)); break;
          case 1: data = sign_extend<32>(b16(data)); break;
          case 4: data = b8(data); break;
          case 5: data = b16(data); break;
        }
        // clang-format on

        if (rd) regs[rd] = data;
        pc = pc + 4;
      }

      //----------

      else if (op == OP_STORE) {
        logic<32> imm = cat(dup<21>(inst[31]), b6(inst, 25), b5(inst, 7));
        logic<32> addr = regs[r1] + imm;
        logic<32> data = regs[r2] << (8 * b2(addr));

        logic<32> mask = 0;
        if (f3 == 0) mask = 0x000000FF << (8 * b2(addr));
        if (f3 == 1) mask = 0x0000FFFF << (8 * b2(addr));
        if (f3 == 2) mask = 0xFFFFFFFF;

        logic<15> phys_addr = b15(addr, 2);
        data_mem[phys_addr] = (data_mem[phys_addr] & ~mask) | (data & mask);

        pc = pc + 4;

        bus_address = addr;
        bus_write_enable = 1;
        bus_write_data = regs[r2];
      }

      //----------

      else if (op == OP_BRANCH) {
        logic<32> op_a = regs[r1];
        logic<32> op_b = regs[r2];

        // clang-format off
        logic<1> take_branch;
        switch (f3) {
          case 0: take_branch = op_a == op_b; break;
          case 1: take_branch = op_a != op_b; break;
          case 4: take_branch = signed(op_a) < signed(op_b); break;
          case 5: take_branch = signed(op_a) >= signed(op_b); break;
          case 6: take_branch = op_a < op_b; break;
          case 7: take_branch = op_a >= op_b; break;
          // KCOV_OFF
          default: take_branch = b1(DONTCARE); break;
          // KCOV_ON
        }
        // clang-format on

        if (take_branch) {
          logic<32> imm =
              cat(dup<20>(inst[31]), inst[7], b6(inst, 25), b4(inst, 8), b1(0));
          pc = pc + imm;
        } else {
          pc = pc + 4;
        }
      }

      //----------

      else if (op == OP_JAL) {
        logic<32> imm = cat(dup<12>(inst[31]), b8(inst, 12), inst[20],
                            b6(inst, 25), b4(inst, 21), b1(0));
        if (rd) regs[rd] = pc + 4;
        pc = pc + imm;
      }

      //----------

      else if (op == OP_JALR) {
        logic<32> rr1 = regs[r1];  // Lol, Metron actually found a bug - gotta
                                   // read r1 before writing
        logic<32> imm = cat(dup<21>(inst[31]), b6(inst, 25), b5(inst, 20));
        if (rd) regs[rd] = pc + 4;
        pc = rr1 + imm;
      }

      //----------

      else if (op == OP_LUI) {
        logic<32> imm = cat(inst[31], b11(inst, 20), b8(inst, 12), b12(0));
        if (rd) regs[rd] = imm;
        pc = pc + 4;
      }

      //----------

      else if (op == OP_AUIPC) {
        logic<32> imm = cat(inst[31], b11(inst, 20), b8(inst, 12), b12(0));
        if (rd) regs[rd] = pc + imm;
        pc = pc + 4;
      }
    }
  }

  logic<32> text_mem[32 * 1024];
  logic<32> data_mem[32 * 1024];
  logic<32> regs[32];
};
Verilated version of https://www.fpga4fun.com/PongGame.html
Original source from https://www.fpga4fun.com/PongGame.html
#pragma once
#include "metron_tools.h"

//------------------------------------------------------------------------------

/*
640x480x60
Pixel clock 25.175 MHz

Screen X    [000-639]
Front porch [640-655]
HSync       [656-751]
Back porch  [752-799]

Screen Y    [000-479]
Front porch [480-489]
VSync       [490-491]
Back porch  [492-524]
*/

class Pong {
 public:
  logic<1> vga_hsync;
  logic<1> vga_vsync;
  logic<1> vga_R;
  logic<1> vga_G;
  logic<1> vga_B;

  //----------------------------------------

  Pong() {
    px = 0;
    py = 0;

    ball_x = 320;
    ball_y = 240;

    ball_dx = 1;
    ball_dy = 1;

    pad_x = 240;
    pad_y = 400;

    quad_a = 0;
    quad_b = 0;
  }

  //----------------------------------------

  logic<10> pix_x() const { return px; }
  logic<10> pix_y() const { return py; }

  //----------------------------------------

  void tock_video() {
    vga_hsync = !((px >= 656) && (py <= 751));
    vga_vsync = !((py >= 490) && (py <= 491));

    if ((px < 640) && (py < 480)) {
      vga_R = in_border() | in_paddle() | in_ball() | in_checker();
      vga_G = in_border() | in_paddle() | in_ball();
      vga_B = in_border() | in_paddle() | in_ball();
    } else {
      vga_R = 0;
      vga_G = 0;
      vga_B = 0;
    }
  }

  //----------------------------------------

  void tock_game(logic<1> in_quad_a, logic<1> in_quad_b) {
    tick(in_quad_a, in_quad_b);
  }

  //----------------------------------------

 private:
  void tick(logic<1> in_quad_a, logic<1> in_quad_b) {
    logic<10> new_px = px + 1;
    logic<10> new_py = py;

    //----------
    // Update screen coord

    if (new_px == 800) {
      new_px = 0;
      new_py = new_py + 1;
    }

    if (new_py == 525) {
      new_py = 0;
    }

    //----------
    // Update quadrature encoder

    logic<1> quad_dir = quad_a[1] ^ quad_b[0];
    logic<1> quad_step = quad_a[1] ^ quad_a[0] ^ quad_b[1] ^ quad_b[0];

    logic<10> new_pad_x = pad_x;
    logic<10> new_pad_y = pad_y;

    if (quad_step) {
      new_pad_x = pad_x + quad_dir ? 1 : 0;
      if (new_pad_x < 120) new_pad_x = 120;
      if (new_pad_x > 520) new_pad_x = 520;
    }

    //----------
    // Update in_ball

    logic<10> new_ball_x = ball_x;
    logic<10> new_ball_y = ball_y;
    logic<1> new_ball_dx = ball_dx;
    logic<1> new_ball_dy = ball_dy;

    if (in_border() | in_paddle()) {
      if ((px == ball_x - 7) && (py == ball_y + 0)) new_ball_dx = 1;
      if ((px == ball_x + 7) && (py == ball_y + 0)) new_ball_dx = 0;
      if ((px == ball_x + 0) && (py == ball_y - 7)) new_ball_dy = 1;
      if ((px == ball_x + 0) && (py == ball_y + 7)) new_ball_dy = 0;
    }

    if (new_px == 0 && new_py == 0) {
      new_ball_x = ball_x + (new_ball_dx ? 1 : -1);
      new_ball_y = ball_y + (new_ball_dy ? 1 : -1);
    }

    //----------
    // Commit

    px = new_px;
    py = new_py;

    pad_x = new_pad_x;
    pad_y = new_pad_y;

    ball_x = new_ball_x;
    ball_y = new_ball_y;

    ball_dx = new_ball_dx;
    ball_dy = new_ball_dy;

    quad_a = quad_a << 1 | in_quad_a;
    quad_b = quad_b << 1 | in_quad_b;
  }

  //----------------------------------------

  logic<1> in_border() const {
    return (px <= 7) || (px >= 633) || (py <= 7) || (py >= 473);
  }

  logic<1> in_paddle() const {
    return (px >= pad_x - 63) && (px <= pad_x + 63) && (py >= pad_y - 3) &&
           (py <= pad_y + 3);
  }

  logic<1> in_ball() const {
    return (px >= ball_x - 7) && (px <= ball_x + 7) && (py >= ball_y - 7) &&
           (py <= ball_y + 7);
  }

  logic<1> in_checker() const { return px[3] ^ py[3]; }

  logic<10> px;
  logic<10> py;

  logic<10> pad_x;
  logic<10> pad_y;

  logic<10> ball_x;
  logic<10> ball_y;

  logic<1> ball_dx;
  logic<1> ball_dy;

  logic<2> quad_a;
  logic<2> quad_b;
};

//------------------------------------------------------------------------------
A simple UART-based testbench for Metron that exercises translation to
SystemVerilog, simulation via Icarus, translation back to C via Verilator,
synthesis via Yosys, place+route via NextPNR, and uploading to a Lattice ICE40
fpga via Icestorm.
#ifndef UART_TX_H
#define UART_TX_H

#include "metron_tools.h"

//==============================================================================

template <int cycles_per_bit = 4>
class uart_tx {
public:
  uart_tx() {
    bit_delay = bit_delay_max;
    bit_count = bit_count_max;
    output_buffer = 0;
  }

  // The actual bit of data we're sending to the serial port.
  logic<1> get_serial() const {
    return output_buffer & 1;
  }

  // True if the transmitter is ready to accept another byte.
  logic<1> get_clear_to_send() const {
    return ((bit_count == bit_count_done) && (bit_delay == bit_delay_max)) ||
           (bit_count > bit_count_done);
  }

  // True if the transmitter has sent the message plus the extra stop bits.
  logic<1> get_idle() const {
    return (bit_count == bit_count_max) && (bit_delay == bit_delay_max);
  }

  void tick(logic<1> reset, logic<8> send_data, logic<1> send_request) {
    if (reset) {
      bit_delay = bit_delay_max;
      bit_count = bit_count_max;
      output_buffer = 0x1FF;
    }

    else {
      // If we've just sent a bit, wait for the delay to expire before sending
      // another.
      if (bit_delay < bit_delay_max) {
        bit_delay = bit_delay + 1;
      }

      // The bit delay is done. If we have more bits to send, shift our output
      // buffer over and append a stop bit.
      else if (bit_count < bit_count_done) {
        bit_delay = 0;
        bit_count = bit_count + 1;
        output_buffer = (output_buffer >> 1) | 0x100;
      }

      // If we don't have any more bits to send, check for a new send request.
      else if (send_request) {
        bit_delay = 0;
        bit_count = 0;
        // We shift the new byte left by one so that the low 0 bit in the output
        // buffer serves as the start bit for the next byte.
        output_buffer = send_data << 1;
      }

      // If there was no send request, keep sending extra stop bits until we've
      // sent enough.
      else if (bit_count < bit_count_max) {
        bit_delay = 0;
        bit_count = bit_count + 1;
      }
    }
  }

private:

  // We wait {cycles_per_bit} cycles between sending bits.
  static const int bit_delay_width = clog2(cycles_per_bit);
  static const int bit_delay_max   = cycles_per_bit - 1;
  logic<bit_delay_width> bit_delay;

  // We send 1 start bit, 8 data bits, and 1 stop bit per byte = 10 bits per
  // byte total. We also send 7 additional stop bits between messages to
  // guarantee that the receiver can resynchronize with our start bit.

  static const int bit_count_done  = 10;
  static const int extra_stop_bits = 7;
  static const int bit_count_width = clog2(10 + extra_stop_bits);
  static const int bit_count_max   = bit_count_done + extra_stop_bits;
  logic<bit_count_width> bit_count;

  // Our output buffer is 9 (not 8) bits wide so that the low bit can serve as
  // our start bit.
  logic<9> output_buffer;
};

//==============================================================================

#endif // UART_TX_H
#ifndef UART_TOP_H
#define UART_TOP_H

#include "metron_tools.h"
#include "uart_hello.h"
#include "uart_rx.h"
#include "uart_tx.h"

//==============================================================================

template <int cycles_per_bit = 3, int repeat_msg = 0>
class uart_top {
public:

  // The actual bit of data currently on the transmitter's output
  logic<1> get_serial() const {
    return tx.get_serial();
  }

  // Returns true if the receiver has a byte in its buffer
  logic<1> get_valid() const {
    return rx.get_valid();
  }

  // The next byte of data from the receiver
  logic<8> get_data_out() const {
    return rx.get_data_out();
  }

  // True if the client has sent its message and the transmitter has finished
  // transmitting it.
  logic<1> get_done() const {
    return hello.get_done() && tx.get_idle();
  }

  // Checksum of all the bytes received
  logic<32> get_checksum() const {
    return rx.get_checksum();
  }

  void tock(logic<1> reset) {
    // Grab signals from our submodules before we tick them.
    logic<8> data = hello.get_data();
    logic<1> request = hello.get_request();

    logic<1> serial = tx.get_serial();
    logic<1> clear_to_send = tx.get_clear_to_send();
    logic<1> idle = tx.get_idle();

    // Tick all submodules.
    hello.tick(reset, clear_to_send, idle);
    tx.tick(reset, data, request);
    rx.tick(reset, serial);
  }

  //----------------------------------------
private:
  uart_hello<repeat_msg>  hello; // Our UART client that transmits our "hello world" test message
  uart_tx<cycles_per_bit> tx;    // The UART transmitter
  uart_rx<cycles_per_bit> rx;    // The UART receiver
};

//==============================================================================

#endif // UART_TOP_H
#ifndef UART_HELLO_H
#define UART_HELLO_H

#include "metron_tools.h"

//==============================================================================

template <int repeat_msg = 0>
class uart_hello {
public:
  uart_hello() {
    readmemh("examples/uart/message.hex", memory, 0, 511);
  }

  // The byte of data we want transmitted is always the one at the cursor.
  logic<8> get_data() const {
    return memory[cursor];
  }

  // True if we want to transmit a byte
  logic<1> get_request() const {
    return state == SEND;
  }

  // True if we've transmitted the whole message.
  logic<1> get_done() const {
    return state == DONE;
  }

  void tick(
    logic<1> reset,          // Top-level reset signal.
    logic<1> clear_to_send,  // True if the transmitter can accept an input byte
    logic<1> idle)           // True if the transmitter is idle
  {
    // In reset we're always in WAIT state with the message cursor set to
    // the start of the message buffer.
    if (reset) {
      state = WAIT;
      cursor = 0;
    }

    else {

      // If we're waiting for the transmitter to be free and it's told us that
      // it's idle, go to SEND state.
      if (state == WAIT && idle) {
        state = SEND;
      }

      // If we're currently sending a message and the transmitter is ready to
      // accept another byte,
      else if (state == SEND && clear_to_send) {
        // either go to DONE state if we're about to send the last character of
        // the message
        if (cursor == message_len - 1) {
          state = DONE;
        }

        // or just advance the message cursor.
        else {
          cursor = cursor + 1;
        }
      }

      // If we've finished transmitting, reset the message cursor and either go
      // back to WAIT state if we want to re-transmit or just stay in DONE
      // otherwise.
      else if (state == DONE) {
        cursor = 0;
        if (repeat_msg) state = WAIT;
      }
    }
  }

private:
  static const int message_len = 512;
  static const int cursor_bits = clog2(message_len);

  static const int WAIT = 0; // Waiting for the transmitter to be free
  static const int SEND = 1; // Sending the message buffer
  static const int DONE = 2; // Message buffer sent
  logic<2> state;            // One of the above states

  logic<8> memory[512];      // The buffer preloaded with our message
  logic<cursor_bits> cursor; // Index into the message buffer of the _next_ character to transmit
};

//==============================================================================

#endif // UART_HELLO_H
#ifndef UART_RX_H
#define UART_RX_H

#include "metron_tools.h"

//==============================================================================

template <int cycles_per_bit = 4>
class uart_rx {
public:

  // Our output is valid once we've received 8 bits.
  logic<1> get_valid() const {
    return bit_count == 8;
  }

  // The most recent data byte received.
  logic<8> get_data_out() const {
    return data_out;
  }

  // The checksum of all bytes received so far.
  logic<32> get_checksum() const {
    return checksum;
  }

  void tick(
    logic<1> reset,  // Top-level reset signal
    logic<1> serial) // Serial input from the transmitter
  {
    if (reset) {
      bit_delay = bit_delay_max;
      bit_count = bit_count_max;
      data_out = 0;
      checksum = 0;
    }
    else {

      // If we're waiting for the next bit to arrive, keep waiting until our
      // bit delay counter runs out.
      if (bit_delay < bit_delay_max) {
        bit_delay = bit_delay + 1;
      }

      // We're done waiting for a bit. If we have bits left to receive, shift
      // them into the top of the output register.
      else if (bit_count < bit_count_max) {
        logic<8> new_output = (serial << 7) | (data_out >> 1);

        // If that was the last data bit, add the finished byte to our checksum.
        if (bit_count == 7) {
          checksum = checksum + new_output;
        }

        // Move to the next bit and reset our delay counter.
        bit_delay = 0;
        bit_count = bit_count + 1;
        data_out = new_output;
      }

      // We're not waiting for a bit and we finished receiving the previous
      // byte. Wait for the serial line to go low, which signals the start of
      // the next byte.
      else if (serial == 0) {
        bit_delay = 0;
        bit_count = 0;
      }
    }
  }

 private:
  // We wait for cycles_per_bit cycles
  static const int bit_delay_width = clog2(cycles_per_bit);
  static const int bit_delay_max = cycles_per_bit - 1;
  logic<bit_delay_width> bit_delay;

  // Our serial data format is 8n1, which is short for "one start bit, 8 data
  // bits, no parity bit, one stop bit". If bit_count == 1, we're only waiting
  // on the stop bit.
  static const int bit_count_max = 9;
  static const int bit_count_width = clog2(bit_count_max);
  logic<bit_count_width> bit_count;

  // The received byte
  logic<8> data_out;

  // The checksum of all bytes received so far.
  logic<32> checksum;
};

//==============================================================================

#endif // UART_RX_H
#include "metron_tools.h"
#include "dpram.h"

class J1 {
public:

  logic<1>  io_rd;
  logic<1>  io_wr;
  logic<16> io_addr;
  logic<16> io_dout;
  logic<16> io_din;

  void tock(logic<1> sys_rst_i) {
    tick(sys_rst_i);
  }

private:

  // The RAM
  DPRam dpram;

  // The D and R stacks
  logic<16> dstack[32];
  logic<16> rstack[32];

  logic<16> insn;
  logic<16> ramrd;

  logic<13> pc;
  logic<16> st0;
  logic<5>  dsp;
  logic<5>  rsp;

  //----------------------------------------

  void tick(logic<1> sys_rst_i) {
    logic<5>  _dsp;
    logic<16> _st0;
    logic<1>  _dstkW;
    logic<1>  _rstkW;
    logic<16> _rstkD;
    logic<13> _pc;
    logic<5>  _rsp;

    enum {
      OP_JUMP = 0b000,
      OP_CJMP = 0b001,
      OP_CALL = 0b010,
      OP_ALU  = 0b011,
    };

    insn = dpram.porta_dout;
    ramrd = dpram.portb_dout;

    logic<16> dd = b2(insn, 0).as_signed();
    logic<16> rd = b2(insn, 2).as_signed();
    logic<1>  op_store = insn[5];

    logic<3> opcode = b3(insn, 13);
    logic<1> is_lit = insn[15];
    logic<16> st1 = dstack[dsp];

    logic<4> st0sel;
    switch(b2(insn, 13)) {
      case 0:  st0sel = 0; break;
      case 1:  st0sel = 0; break;
      case 2:  st0sel = 1; break;
      case 3:  st0sel = b4(insn, 8); break;
    }

    // Compute the new value of T.
    logic<16> st1 = dstack[dsp];
    logic<16> rst0 = rstack[rsp];


    if (is_lit) {
      _st0 = cat(b1(0), b15(insn));
    }
    else {
      switch (st0sel) {
        case 0b0000: _st0 = st0; break;
        case 0b0001: _st0 = st1; break;
        case 0b0010: _st0 = st0 + st1; break;
        case 0b0011: _st0 = st0 & st1; break;
        case 0b0100: _st0 = st0 | st1; break;
        case 0b0101: _st0 = st0 ^ st1; break;
        case 0b0110: _st0 = ~st0; break;
        case 0b0111: _st0 = dup<16>(b1(st1 == st0)); break;
        case 0b1000: _st0 = dup<16>(b1(signed(st1) < signed(st0))); break;
        case 0b1001: _st0 = st1 >> b4(st0); break;
        case 0b1010: _st0 = st0 - 1; break;
        case 0b1011: _st0 = rst0; break;
        case 0b1100: _st0 = b2(st0, 14) ? io_din : ramrd; break;
        case 0b1101: _st0 = st1 << b4(st0); break;
        case 0b1110: _st0 = cat(rsp, b3(0), dsp); break;
        case 0b1111: _st0 = dup<16>(b1(st1 < st0)); break;
        default:     _st0 = b16(DONTCARE); break;
      }
    }

    if (is_lit) {
      _dsp = dsp + 1;
      _rsp = rsp;
      _rstkW = 0;
      _rstkD = _pc;
      _pc = pc + 1;
    }
    else if (opcode == OP_JUMP) {
      _dsp = dsp;
      _rsp = rsp;
      _rstkW = 0;
      _rstkD = _pc;
      _pc = b13(insn);
    }
    else if (opcode == OP_CJMP) {
      // predicated jump is like DROP
      _dsp = dsp - 1;
      _rsp = rsp;
      _rstkW = 0;
      _rstkD = _pc;
      _pc = st0 ? b13(pc + 1) : b13(insn);
    }
    else if (opcode == OP_CALL) {
      _dsp = dsp;
      _rsp = rsp + 1;
      _rstkW = 1;
      _rstkD = cat(b15(pc + 1), b1(0));
      _pc = b13(insn);
    }
    else if (opcode == OP_ALU) {
      _dsp = dsp + b2(insn, 0).as_signed();
      _rsp = rsp + b2(insn, 2).as_signed();
      _rstkW = insn[6];
      _rstkD = st0;
      _pc = insn[12] ? b13(rst0, 1) : b13(pc + 1);
    }


    logic<1> _ramWE = (opcode == OP_ALU) & op_store;

    dpram.tick(
      b16(pc),                      // porta_addr
      b16(_st0, 1),                 // portb_addr
      _ramWE & (b2(_st0, 14) == 0), // portb_write
      b16(st1));                       // portb_data

    logic<1> _dstkW = is_lit | (opcode == OP_ALU & insn[7]);

    if (_dstkW) dstack[_dsp] = st0;
    if (_rstkW) rstack[_rsp] = _rstkD;

    if (sys_rst_i) {
      pc      = 0;
      st0     = 0;
      dsp     = 0;
      rsp     = 0;
      io_rd   = 0;
      io_wr   = 0;
      io_addr = 0;
      io_dout = 0;
    } else {
      pc  = _pc;
      st0 = _st0;
      dsp = _dsp;
      rsp = _rsp;
      io_rd   = (opcode == OP_ALU && (b4(insn,8) == 0xc));
      io_wr   = opcode == OP_ALU && insn[5];
      io_addr = b16(st0);
      io_dout = dstack[dsp];
    }
  }
};
#include "metron_tools.h"

class DPRam {
public:

  logic<16> porta_dout;
  logic<16> portb_dout;

  void tick(
    logic<16> porta_addr,
    logic<16> portb_addr,
    logic<1> portb_write,
    logic<16> portb_data) {

    porta_dout = ram[porta_addr];

    if (write) {
      ram[portb_addr] = portb_data;
      portb_dout = portb_data;
    }
    else {
      portb_dout = ram[portb_addr];
    }
  }

private:
  logic<16> ram[65536];
};
#include "metron_tools.h"

// Logics can be casted to various sizes via bN() or bx<N>()

class Module {
public:

  int test_bN() {
    logic<64> src = 0x1234567812345678;
    logic<64> dst64 = b64(src);
    logic<63> dst63 = b63(src);
    logic<62> dst62 = b62(src);
    logic<61> dst61 = b61(src);
    logic<60> dst60 = b60(src);

    logic<59> dst59 = b59(src);
    logic<58> dst58 = b58(src);
    logic<57> dst57 = b57(src);
    logic<56> dst56 = b56(src);
    logic<55> dst55 = b55(src);
    logic<54> dst54 = b54(src);
    logic<53> dst53 = b53(src);
    logic<52> dst52 = b52(src);
    logic<51> dst51 = b51(src);
    logic<50> dst50 = b50(src);

    logic<49> dst49 = b49(src);
    logic<48> dst48 = b48(src);
    logic<47> dst47 = b47(src);
    logic<46> dst46 = b46(src);
    logic<45> dst45 = b45(src);
    logic<44> dst44 = b44(src);
    logic<43> dst43 = b43(src);
    logic<42> dst42 = b42(src);
    logic<41> dst41 = b41(src);
    logic<40> dst40 = b40(src);

    logic<39> dst39 = b39(src);
    logic<38> dst38 = b38(src);
    logic<37> dst37 = b37(src);
    logic<36> dst36 = b36(src);
    logic<35> dst35 = b35(src);
    logic<34> dst34 = b34(src);
    logic<33> dst33 = b33(src);
    logic<32> dst32 = b32(src);
    logic<31> dst31 = b31(src);
    logic<30> dst30 = b30(src);

    logic<29> dst29 = b29(src);
    logic<28> dst28 = b28(src);
    logic<27> dst27 = b27(src);
    logic<26> dst26 = b26(src);
    logic<25> dst25 = b25(src);
    logic<24> dst24 = b24(src);
    logic<23> dst23 = b23(src);
    logic<22> dst22 = b22(src);
    logic<21> dst21 = b21(src);
    logic<20> dst20 = b20(src);

    logic<19> dst19 = b19(src);
    logic<18> dst18 = b18(src);
    logic<17> dst17 = b17(src);
    logic<16> dst16 = b16(src);
    logic<15> dst15 = b15(src);
    logic<14> dst14 = b14(src);
    logic<13> dst13 = b13(src);
    logic<12> dst12 = b12(src);
    logic<11> dst11 = b11(src);
    logic<10> dst10 = b10(src);

    logic<9> dst9 = b9(src);
    logic<8> dst8 = b8(src);
    logic<7> dst7 = b7(src);
    logic<6> dst6 = b6(src);
    logic<5> dst5 = b5(src);
    logic<4> dst4 = b4(src);
    logic<3> dst3 = b3(src);
    logic<2> dst2 = b2(src);
    logic<1> dst1 = b1(src);
    return 0;
  }

  int test_bx_const() {
    logic<64> src = 0x1234567812345678;
    logic<63> dst63 = bx<63>(src);
    logic<62> dst62 = bx<62>(src);
    logic<61> dst61 = bx<61>(src);
    logic<60> dst60 = bx<60>(src);

    logic<59> dst59 = bx<59>(src);
    logic<58> dst58 = bx<58>(src);
    logic<57> dst57 = bx<57>(src);
    logic<56> dst56 = bx<56>(src);
    logic<55> dst55 = bx<55>(src);
    logic<54> dst54 = bx<54>(src);
    logic<53> dst53 = bx<53>(src);
    logic<52> dst52 = bx<52>(src);
    logic<51> dst51 = bx<51>(src);
    logic<50> dst50 = bx<50>(src);

    logic<49> dst49 = bx<49>(src);
    logic<48> dst48 = bx<48>(src);
    logic<47> dst47 = bx<47>(src);
    logic<46> dst46 = bx<46>(src);
    logic<45> dst45 = bx<45>(src);
    logic<44> dst44 = bx<44>(src);
    logic<43> dst43 = bx<43>(src);
    logic<42> dst42 = bx<42>(src);
    logic<41> dst41 = bx<41>(src);
    logic<40> dst40 = bx<40>(src);

    logic<39> dst39 = bx<39>(src);
    logic<38> dst38 = bx<38>(src);
    logic<37> dst37 = bx<37>(src);
    logic<36> dst36 = bx<36>(src);
    logic<35> dst35 = bx<35>(src);
    logic<34> dst34 = bx<34>(src);
    logic<33> dst33 = bx<33>(src);
    logic<32> dst32 = bx<32>(src);
    logic<31> dst31 = bx<31>(src);
    logic<30> dst30 = bx<30>(src);

    logic<29> dst29 = bx<29>(src);
    logic<28> dst28 = bx<28>(src);
    logic<27> dst27 = bx<27>(src);
    logic<26> dst26 = bx<26>(src);
    logic<25> dst25 = bx<25>(src);
    logic<24> dst24 = bx<24>(src);
    logic<23> dst23 = bx<23>(src);
    logic<22> dst22 = bx<22>(src);
    logic<21> dst21 = bx<21>(src);
    logic<20> dst20 = bx<20>(src);

    logic<19> dst19 = bx<19>(src);
    logic<18> dst18 = bx<18>(src);
    logic<17> dst17 = bx<17>(src);
    logic<16> dst16 = bx<16>(src);
    logic<15> dst15 = bx<15>(src);
    logic<14> dst14 = bx<14>(src);
    logic<13> dst13 = bx<13>(src);
    logic<12> dst12 = bx<12>(src);
    logic<11> dst11 = bx<11>(src);
    logic<10> dst10 = bx<10>(src);

    logic<9> dst9 = bx<9>(src);
    logic<8> dst8 = bx<8>(src);
    logic<7> dst7 = bx<7>(src);
    logic<6> dst6 = bx<6>(src);
    logic<5> dst5 = bx<5>(src);
    logic<4> dst4 = bx<4>(src);
    logic<3> dst3 = bx<3>(src);
    logic<2> dst2 = bx<2>(src);
    logic<1> dst1 = bx<1>(src);
    return 0;
  }

  int test_bN_offset() {
    logic<64> src = 0x1234567812345678;

    logic<8> dst0 = b8(src, 0);
    logic<8> dst1 = b8(src, 1);
    logic<8> dst2 = b8(src, 2);
    logic<8> dst3 = b8(src, 3);
    logic<8> dst4 = b8(src, 4);
    logic<8> dst5 = b8(src, 5);
    logic<8> dst6 = b8(src, 6);
    logic<8> dst7 = b8(src, 7);
    logic<8> dst8 = b8(src, 8);
    logic<8> dst9 = b8(src, 9);
    return 0;
  }

  static const int some_size1 = 64;
  static const int some_size2 = 8;

  int test_bx_param() {
    logic<some_size1> a = 10;
    logic<some_size2> b = bx<some_size2>(a);

    logic<some_size2> b0 = bx<some_size2>(a, 0);
    logic<some_size2> b1 = bx<some_size2>(a, 1);
    logic<some_size2> b2 = bx<some_size2>(a, 2);
    logic<some_size2> b3 = bx<some_size2>(a, 3);
    logic<some_size2> b4 = bx<some_size2>(a, 4);
    logic<some_size2> b5 = bx<some_size2>(a, 5);
    logic<some_size2> b6 = bx<some_size2>(a, 6);
    logic<some_size2> b7 = bx<some_size2>(a, 7);
    logic<some_size2> b8 = bx<some_size2>(a, 8);
    logic<some_size2> b9 = bx<some_size2>(a, 9);

    return 0;
  }


  int test2() {
    logic<32> a = 0xDEADBEEF;

    logic<1> b = b1(a, 3); //static bit extract with literal offset, width 1
    logic<7> c = b7(a, 3); //static bit extract with literal offset, width N

    logic<1> e = b1(a, some_size1); //static bit extract with variable offset, width 1
    logic<7> f = b7(a, some_size2); //static bit extract with variable offset, width N

    return 0;
  }



};
#include "metron_tools.h"

// Comments surrounded by / * # <something # * / get unwrapped and dropped
// directly in the output file.

class Module {
public:

  void tick() {
    my_reg = my_reg + 1;
  }

/*#
  always @(posedge clock) begin
    //$display("Hello World!\n");
  end
#*/

  int my_reg;
};
#include "metron_tools.h"

// Tocks should be able to call private tasks and functions

class Module {
public:

  logic<8> my_signal;

  int tock() {
    return set_signal(get_number());
  }

  logic<8> get_number() const {
    return 7;
  }

  int set_signal(logic<8> number) {
    my_signal = number;
    return my_signal;
  }

};
#include "metron_tools.h"

// Structs exist in both C++ and Verilog

struct MyStruct1 {
  logic<8> a;
};

class Module {
public:

  MyStruct1 my_struct1;

  logic<8> tock() {
    my_struct1.a = 1;
    return 17;
  }
};
#include "metron_tools.h"

// Public register member variables get moved to the output port list.

class Module {
public:
  void tock() {
    tick();
  }
  logic<1> my_reg;

private:
  void tick() {
    my_reg = my_reg + 1;
  }
};
#include "metron_tools.h"

// Increment/decrement should be translated into equivalent Verilog, but they
// do _not_ return the old/new value.

class Module {
public:

  void tock() {
    tick();
  }

private:

  void tick() {
    my_reg1++;
    ++my_reg2;
    my_reg3--;
    --my_reg4;
  }

  int my_reg1;
  int my_reg2;
  int my_reg3;
  int my_reg4;
};
#include "metron_tools.h"

// Concatenating logics should produce logics with correct <N>

class Module {
public:

  Module() {
    write("Hello World?\n");
  }

  logic<6> sig1;
  logic<6> sig2;

  void tock1() {
    logic<1> a = 1;
    logic<2> b = 2;
    logic<3> c = 3;

    sig1 = cat(a, b, c);
  }

  void tock2() {
    logic<8> a = 1;
    logic<8> b = 2;
    logic<8> c = 3;

    sig2 = cat(b1(a), b2(b), b3(c));
  }
};
#include "metron_tools.h"

// Nesting submod calls should put all the nested input bindings above the call.

class Submod1 {
public:
  logic<8> add_one(logic<8> a) const {
    return a + 1;
  }
};

class Submod2 {
public:
  logic<8> add_two(logic<8> a) const {
    return a + 1;
  }
};

class Module {
public:

  logic<8> tock(logic<8> old_counter) {
    // Two bindings should end up here.
    logic<8> new_counter = submod1.add_one(submod2.add_two(old_counter));
    return new_counter;
  }

private:

  Submod1 submod1;
  Submod2 submod2;
};
#include "metron_tools.h"

class Module {
public:

  int test_dup1() {
    logic<1> a1 = 0b1;
    logic<1> b1 = dup<1>(a1);
    return 0;
  }

  int test_dup4() {
    logic<1>  a1 = 0b1;
    logic<4>  b1 = dup<4>(a1);

    logic<2>  a2 = 0b01;
    logic<8>  b2 = dup<4>(a2);

    logic<3>  a3 = 0b001;
    logic<12> b3 = dup<4>(a3);

    logic<4>  a4 = 0b0001;
    logic<16> b4 = dup<4>(a4);

    logic<5>  a5 = 0b00001;
    logic<20> b5 = dup<4>(a5);

    logic<6>  a6 = 0b000001;
    logic<24> b6 = dup<4>(a6);

    logic<7>  a7 = 0b0000001;
    logic<28> b7 = dup<4>(a7);

    logic<8>  a8 = 0b00000001;
    logic<32> b8 = dup<4>(a8);
    return 0;
  }
};
#include "metron_tools.h"

// All the combos of tasks/funcs should work from ticks and tocks.

// Yosys bug - fails to parse if we pass constants between the functions
// https://github.com/YosysHQ/yosys/issues/3327

class Module {
public:

  logic<8> my_sig;

  void tock(int z) {
    logic<8> dummy = public_task(public_func(z));
    tick(z);
  }

  logic<8> public_task(logic<8> x) {
    my_sig = x + 7;
    return 0;
  }

  logic<8> public_func(logic<8> x) {
    return my_reg1 + private_func(x);
  }

private:

  void tick(int w) {
    private_task(private_func(w));
    my_reg2 = my_reg2 + 1;
  }

  void private_task(logic<8> x) {
    my_reg1 = my_reg1 + private_func(x);
  }

  logic<8> private_func(logic<8> y) {
    return my_reg1 + y;
  }

  logic<8> my_reg1;
  logic<8> my_reg2;
};
#include "metron_tools.h"

// Modules can use constructors to initialize state

class Module {
public:

  Module() {
    my_reg = 7;
  }

  logic<8> get_reg() {
    return my_reg;
  }

private:

  logic<8> my_reg;
};

/*#
`ifdef IVERILOG
module Test;
  logic clock;
  logic[7:0] tock;
  Module mod(.clock(clock), .tock(tock));
  initial begin
    if (tock != 7) $display("FAIL");
  end
endmodule
`endif
#*/
#include "metron_tools.h"

// Template parameters become SV module parameters.

template<int SOME_CONSTANT = 7>
class Module {
public:

  void tock() {
    tick();
  }

private:

  void tick() {
    my_reg = my_reg + SOME_CONSTANT;
  }

  logic<7> my_reg;
};
#include "metron_tools.h"

// I don't know why you would want to do this, but it should work.

class Module {
public:
  Module() {
    init1();
  }

  int tock() {
    tick();
    return 0;
  }

private:

  void tick() {
    reg1 = reg1 + 1;
    reg2 = reg2 + 1;
    reg3 = reg3 + 1;
    reg4 = reg4 + 1;
    reg5 = reg5 + 1;
  }

  logic<8> reg1;
  logic<8> reg2;
  logic<8> reg3;
  logic<8> reg4;
  logic<8> reg5;

  void init1() {
    reg1 = 1;
    init2();
  }

  void init2() {
    reg2 = 2;
    init3();
  }

  void init3() {
    reg3 = 3;
    init4();
  }

  void init4() {
    reg4 = 4;
    init5();
  }

  void init5() {
    reg5 = 5;
  }

};
#include "metron_tools.h"

// Private const methods should turn into SV functions.

class Module {
public:

  void tock() {
    tick();
  }

private:

  void tick() {
    my_reg = my_reg + some_func();
  }

  logic<8> some_func() const {
    return 3;
  }

  logic<8> my_reg;
};
#include "metron_tools.h"

class Module {
public:


  /*
  // but why would you do this?
  void func_no_params_no_return() {
  }

  // or this?
  void func_params_no_return(int x) {
  }
  */

  int func_no_params_return() {
    return 1;
  }

  int func_params_return(int x) {
    return x + 1;
  }

  int my_sig1;
  void tock_no_params_no_return() {
    my_sig1 = 12;
    int x = my_sig1;
  }

  int my_sig2;
  int tock_no_params_return() {
    my_sig2 = 12;
    return my_sig2;
  }

  int my_sig3;
  void tock_params_no_return(int x) {
    my_sig3 = 12 + x;
    int y = my_sig3;
  }

  int my_sig4;
  int tock_params_return(int x) {
    my_sig4 = 12 + x;
    return my_sig4;
  }

  int my_sig5;
  void tock_calls_funcs(int x) {
    my_sig5 = 12 + my_func5(x);
  }

private:
  int my_func5(int x) {
    return x + 1;
  }
public:

  int my_sig6a;
  int tock_calls_tock(int x) {
    my_sig6a = 12;
    tock_called_by_tock(my_sig6a);
    return 0;
  }

private:
  int my_sig6b;
  void tock_called_by_tock(int x) {
    my_sig6b = x;
  }
public:

  //----------

  int my_reg1;
  void tick_no_params() {
    my_reg1 = my_reg1 + 1;
    tick_called_by_tick(func_called_by_tick(1));
  }

  int my_reg2;
  void tick_params(int x) {
    my_reg2 = my_reg2 + x;
  }

  int my_reg3;
  void tick_called_by_tick(int x) {
    my_reg3 = my_reg3 + x;
  }

private:
  int func_called_by_tick(int x) {
    return x + 7;
  }
public:

  void only_calls_private_tick() {
    private_tick(17);
  }

private:
  int my_reg4;
  void private_tick(int x) {
    my_reg4 = my_reg4 + x;
  }


};
class Metron {
public:

  int my_sig;

  void tock() {
    int x = 7;
    x += 13;
    x -= 13;
    x *= 13;
    x /= 13;
    x %= 13;
    my_sig = x;
  }

  int my_reg1;
  int my_reg2;
  int my_reg3;
  int my_reg4;
  int my_reg5;

  void tick() {
    my_reg1 += 22;
    my_reg2 -= 22;
    my_reg3 *= 22;
    my_reg4 /= 22;
    my_reg5 %= 22;
  }
};
#include "metron_tools.h"

// Simple switch statements are OK.

class Module {
public:

  void tock(logic<2> selector) {
    tick(selector);
  }

private:

  void tick(logic<2> selector) {
    switch(selector) {
      case 0: // comment
        my_reg = 17; break;
      case 1:  // comment
        my_reg = 22; break;
      case 2: my_reg = 30; break;
      case 3: // fallthrough
      case 4:
      case 5:
      case 6: my_reg = 72; break;
    }
  }

  logic<8> my_reg;
};
#include "metron_tools.h"

// DONTCARE gets translated to 1'bx

class Module {
public:

  // FIXME why is this broken?
  /*
  logic<8> test1() {
    return DONTCARE;
  }
  */

  logic<8> test2() {
    return b8(DONTCARE);
  }

  logic<8> test3() {
    return bx<8>(DONTCARE);
  }
};
#include "metron_tools.h"

// Number literals
// don't forget the ' spacers

class Module {
public:

  int test1() {
    logic<32> a = 0b0;
    logic<32> b = 0b00;
    logic<32> c = 0b000;
    logic<32> d = 0b0000;
    logic<32> e = 0b00000;
    logic<32> f = 0b000000;
    logic<32> g = 0b0000000;
    logic<32> h = 0b00000000;
    return 0;
  }

  int test2() {
    logic<32> a = 0b0;
    logic<32> b = 0b0'0;
    logic<32> c = 0b0'00;
    logic<32> d = 0b00'00;
    logic<32> e = 0b00'000;
    logic<32> f = 0b0'000'00;
    logic<32> g = 0b000'0000;
    logic<32> h = 0b0'0'0'0'0'0'0'0;
    return 0;
  }

};
#include "metron_tools.h"

// Tock methods can return values.

class Module {
public:

  int my_sig;

  int tock() {
    my_sig = 7;
    return my_sig;
  }
};
All the header files in this directory _should_ be convertible to SystemVerilog.
#include "metron_tools.h"

// If statements whose sub-blocks contain submodule calls _must_ use {}.

class Submod {
public:
  void tock(logic<8> arg) {
    tick(arg);
  }
private:
  void tick(logic<8> arg) {
    my_reg = my_reg + arg;
  }

  logic<8> my_reg;
};


class Module {
public:

  void tock() {
    if (1) {
      submod.tock(72);
    }
    else {
      submod.tock(36);
    }
  }

  Submod submod;
};
#include "metron_tools.h"

// Trivial adder just for example.

class Adder {
public:

  logic<8> add(logic<8> a, logic<8> b) {
    return a + b;
  }

};
#include "metron_tools.h"

// UTF-8 text files with a byte order mark should be supported.

// From https://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html:

/*
Runes:

  ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ

  (Old English, which transcribed into Latin reads 'He cwaeth that he
  bude thaem lande northweardum with tha Westsae.' and means 'He said
  that he lived in the northern land near the Western Sea.')
*/

class Module {
public:

  Module() {
    my_reg = 7;
  }

  logic<8> get_reg() {
    return my_reg;
  }

private:

  logic<8> my_reg;
};
#include "metron_tools.h"

// Tick inputs should become input ports.

// clang-format off
class Module {
 public:

  void tock(logic<7> my_input) {
    tick(my_input);
  }

 private:

  void tick(logic<7> my_input) {
    my_reg = my_reg + my_input;
  }

  logic<7> my_reg;
};
// clang-format on
#include "metron_tools.h"

// Make sure our built-in functions translate.

class Module {
public:

  int sig;

  void tock() {
    logic<8> src = 100;
    logic<8> a = signed(src);
    logic<8> b = unsigned(src);
    logic<8> e = sign_extend<8>(b2(src));
    logic<8> c = clog2(100);
    logic<8> d = pow2(4);
    sig = 1;
  }

};
#include "metron_tools.h"

// Templates can be used for module parameters

template<int WIDTH, int HEIGHT = 2>
class Submod {
public:

  void tock() {
    my_width = bx<WIDTH>(100);
    my_height = bx<HEIGHT>(200);
  }

  logic<WIDTH> my_width;
  logic<HEIGHT> my_height;
};

class Module {
public:

  logic<20> tock() {
    submodule.tock();
    return submodule.my_width + submodule.my_height;
  }

  Submod<10,11> submodule;
};
#include "metron_tools.h"

// Basic #defines should work as long as their contents are simultaneously
// valid C++ and SV

#define MY_CONSTANT1 10
#define MY_CONSTANT2 20
#define MY_OTHER_CONSTANT (MY_CONSTANT1 + MY_CONSTANT2 + 7)

class Module {
public:

  logic<8> test() {
    return MY_OTHER_CONSTANT;
  }

};
#include "metron_tools.h"

// UTF-8 text files with a byte order mark should be supported.

// From https://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html:

/*
Runes:

  ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ

  (Old English, which transcribed into Latin reads 'He cwaeth that he
  bude thaem lande northweardum with tha Westsae.' and means 'He said
  that he lived in the northern land near the Western Sea.')
*/

class Module {
public:

  Module() {
    my_reg = 7;
  }

  logic<8> get_reg() {
    return my_reg;
  }

private:

  logic<8> my_reg;
};
#include "metron_tools.h"

// Submodule bindings should be placed immediately before the statement
// containing the call

class Submod {
public:

  logic<8> sum_a(logic<8> a1, logic<8> a2) const { return a1 + a2; }
  logic<8> sum_b(logic<8> b1, logic<8> b2) const { return b1 + b2; }
};

class Module {
public:

  logic<8> tock_bindings() const {
    logic<8> result;
    // Submod bindings should _not_ end up here.

    {
      // Only sum_a's bindings should be here.
      if (submod.sum_a(1, 2)) {
        // Only sum_b's bindings should be here.
        result = submod.sum_b(3,4);
      }
      else {
        // Only sum_b's bindings should be here.
        result = submod.sum_b(5,6);
      }
    }

    return result;
  }

  Submod submod;
};
#include "metron_tools.h"

// Writing a register multiple times in the same function is OK.

class Module {
public:

  void tock() {
    tick();
  }

private:

  void tick() {
    logic<1> temp = my_reg;
    my_reg = 0;
    my_reg = 1;
  }

  logic<1> my_reg;
};
#include "metron_tools.h"

// Namespaces turn into packages.
// "using" doesn't work in methods right now :/

namespace MyPackage {
  static const int foo = 3;
};

class Module {
public:

  int my_sig;
  int my_reg;

  int tock() {
    my_sig = MyPackage::foo + 1;
    return my_sig;
  }

  void tick() {
    my_reg = my_reg + MyPackage::foo;
  }
};
// Preprocessor macros generally won't work, but include guards should be OK.

#ifndef INCLUDE_GUARDS_H
#define INCLUDE_GUARDS_H

class Module {
public:
  int blah() {
    return 7;
  }
};

#endif
#include "metron_tools.h"

// Private non-const methods should turn into SV tasks.

class Module {
public:

  int tock() {
    tick();
    return 0;
  }

private:

  void tick() {
    my_reg = my_reg + my_reg2 + 3;
    some_task2();
  }

  void some_task2() {
    my_reg2 = my_reg2 + 3;
  }

  logic<8> my_reg;
  logic<8> my_reg2;
};
#include "metron_tools.h"

// Most kinds of C++ enum declarations should work.

// bad
// enum { FOO, BAR, BAZ };
// typedef enum logic[1:0] { FOO=70, BAR=71, BAZ=72 } blem;
// typedef enum { FOO, BAR=0, BAZ=1 } blem;

// good
// OK enum { FOO, BAR, BAZ } blem;
// enum { FOO=0, BAR=1, BAZ=2 } blem;
// typedef enum { FOO, BAR, BAZ } blem;
// typedef enum { FOO=0, BAR=1, BAZ=2 } blem;
// typedef enum logic[1:0] { FOO, BAR, BAZ } blem;
// typedef enum logic[1:0] { FOO=0, BAR=1, BAZ=2 } blem;

// enum struct {} ? same as enum class

// clang-format off
class Module {
 public:
  enum simple_enum1 { A1, B1, C1 };
  enum simple_enum2 { A2 = 0b01, B2 = 0x02, C2 = 3 };

  enum { A3, B3, C3 } anon_enum_field1;
  enum { A4 = 0b01, B4 = 0x02, C4 = 3 } anon_enum_field2;

  enum class enum_class1 { A5, B5, C5 };
  enum class enum_class2 { A6 = 0b01, B6 = 0x02, C6 = 3 };

  // This is currently broken in TreeSitter
  enum class typed_enum : int { A7 = 0b01, B7 = 0x02, C7 = 3 };
  enum class sized_enum : logic<8>::BASE { A8 = 0b01, B8 = 0x02, C8 = 3 };

  int test1() {
    simple_enum1 e1 = A1;
    simple_enum2 e2 = B2;
    anon_enum_field1 = C3;
    anon_enum_field2 = A4;
    enum_class1 ec1 = enum_class1::B5;
    enum_class2 ec2 = enum_class2::C6;
    typed_enum te1 = typed_enum::A7;
    sized_enum se1 = sized_enum::B8;
    return 1;
  }
};
// clang-format on
#include "metron_tools.h"

// Cramming various statements into one line should not break anything.

class Module {
public:

  logic<8> test() { logic<8> a = 1; a = a + 7; return a; }

  void tick() { if (my_reg & 1) my_reg = my_reg - 7; }

  logic<8> my_reg;

};
#include "metron_tools.h"

class Module {
  public:

  // decl in for
  int loop1() {
    int x = 0;
    for (int i = 0; i < 10; i++) {
      x = x + i;
    }
    return x;
  }

  // decl outside of for
  int loop2() {
    int x = 0;
    int i;
    for (i = 0; i < 10; i++) {
      x = x + i;
    }
    return x;
  }
};
#include "metron_tools.h"

// Private getter methods are OK

class Module {
public:

  int my_sig;

  int tock() {
    my_sig = my_getter();
    return my_sig;
  }

private:

  int my_getter() const {
    return 12;
  }

};
#include "metron_tools.h"

// Multiple tick methods are OK as long as they're all called by tock()

class Module {
public:

  logic<8> tock() {
    logic<8> result = my_reg1 + my_reg2;
    tick1();
    tick2();
    return result;
  }

private:

  void tick1() {
    my_reg1 = 0;
  }

  void tick2() {
    my_reg2 = 1;
  }

  logic<8> my_reg1;
  logic<8> my_reg2;
};
#include "metron_tools.h"

// Declaration order _matters_ - a tock() that reads a reg before the tick()
// that writes it is OK.

class Module {
public:

  void tock() {
    my_sig = my_reg;
    tick();
  }

private:

  void tick() {
    my_reg = 1;
  }

  logic<1> my_sig;
  logic<1> my_reg;
};
#include "metron_tools.h"

// Calling tick() from tock() in the same module should work and should
// generate bindings for the tick() call.

class Module {
public:

  void tock(logic<8> val) {
    tick(val);
  }

private:

  void tick(logic<8> val) {
    my_reg = my_reg + val;
  }

  logic<8> my_reg;

};
#include "metron_tools.h"

// Getter methods should turn into outputs.

class Module {
public:

  logic<7> get_reg() const {
    return my_reg;
  }

  void tock() {
    tick();
  }


private:

  void tick() {
    my_reg = my_reg + 1;
  }

  logic<7> my_reg;
};
#include "metron_tools.h"

// Modules can contain other modules.

class Submod {
public:

  void tock() {
    tick();
  }

private:

  void tick() {
    sub_reg = sub_reg + 1;
  }

  logic<8> sub_reg;
};

class Module {
public:

  void tock() {
    submod.tock();
  }

  Submod submod;
};
#include "metron_tools.h"

// Case statements are allowed to have fallthrough, though the SV syntax is
// a bit different.

class Module {
public:

  logic<8> tock() {
    logic<8> result;
    switch(my_reg) {
      case 0: // can we stick comments in here?
      case 1:
      case 2:
        result = 10;
        break;
      case 3: {
        result = 20;
        break;
      }
      default:
        result = 30;
        break;
    }

    tick();
    return result;
  }

private:

  void tick() {
    my_reg = my_reg + 1;
  }

  logic<8> my_reg;
};
#include "metron_tools.h"

// Public signal member variables get moved to the output port list.

class Module {
public:

  void tock() {
    my_sig = 1;
  }

  logic<1> my_sig;
};
#include "metron_tools.h"

// We can instantiated templated classes as submodules.

class Submod {
public:

  void tock() {
    tick();
  }

  logic<8> sub_reg;

private:

  void tick() {
    sub_reg = sub_reg + 1;
  }

};

class Module {
public:

  logic<8> get_submod_reg() const {
    return submod.sub_reg;
  }

  void tock() {
    submod.tock();
  }

  Submod submod;
};
#include "metron_tools.h"

// Port and function arg names can collide, the latter is disambiguated by its
// function name.

class Module {
public:

  int input_val;
  int output1;
  int output2;

  void tock1() {
    output1 = input_val + 7;
  }

  void tock2(int input_val) {
    output2 = input_val + 8;
  }
};
#include "metron_tools.h"

// Public fields that are read by the module but never written become input
// ports.

class Submod {
public:

  logic<8> i_signal;
  logic<8> o_signal;
  logic<8> o_reg;

  logic<8> tock(logic<8> i_param) {
    o_signal = i_signal + i_param;
    tick();
    return o_signal + 7;
  }

private:

  void tick() {
    o_reg = o_reg + o_signal;
  }
};

class Module {
public:

  void tock() {
    submod.i_signal = 12;
    logic<8> submod_return = submod.tock(13);
    my_sig = submod_return + 3;
    tick();
  }

  logic<8> my_reg;

private:

  void tick() {
    my_reg = my_reg + my_sig - 2;
  }

  logic<8> my_sig;

  Submod submod;
};
#include "metron_tools.h"

// Empty module should pass.

class Module {
};
#include "metron_tools.h"

// Yosys doesn't seem to support passing structs as args or returning them from
// functions. :/

struct InnerStruct {
  logic<8> a;
  logic<8> b;
  logic<8> c;
};

struct OuterStruct {
  InnerStruct x;
  InnerStruct y;
  InnerStruct z;
};

class Module {
public:

  OuterStruct s;

  void func1() {
    s.x.a = 1;
    s.x.b = 2;
    s.x.c = 3;
  }

  void func2() {
    s.y.a = 4;
    s.y.b = 5;
    s.y.c = 6;
  }

  void func3() {
    s.z.a = 7;
    s.z.b = 8;
    s.z.c = 9;
  }
};
#include "metron_tools.h"

// We can instantiated templated classes as submodules.

template<int SOME_CONSTANT = 6>
class Submod {
public:

  void tock() {
    tick();
  }

private:

  void tick() {
    sub_reg = sub_reg + SOME_CONSTANT;
  }

  logic<8> sub_reg;
};

class Module {
public:

  void tock() {
    submod.tock();
  }

  Submod<99> submod;
};
#include "metron_tools.h"

// Static const members become SV localparams

class Module {
public:

  void tock() {
    tick();
  }

private:

  static const int my_val = 7;

  void tick() {
    my_reg = my_reg + my_val;
  }

  logic<7> my_reg;
};
#include "metron_tools.h"

// Writing a register multiple times in the same function is OK.

class Module {
public:

  void tock() {
    my_sig = 0;
    my_sig = 1;
    logic<1> temp = my_sig;
  }

  logic<1> my_sig;
};
#include "metron_tools.h"

class Module {
public:

  logic<8> func() {
    static const int thing1 = 1;
    const int thing2 = 2;
    return thing1 + thing2;
  }

};
#include "metron_tools.h"

// If for some reason you put a return in the middle of a block, we should catch
// it.

// X Method tock has non-terminal return

class Module {
 public:
  logic<8> tock() {
    logic<8> a = 10;
    logic<8> b = 2;
    logic<8> c;

    c = a + b;
    return c;
    c = b + b;
  }
};
#include "metron_tools.h"

// The tracer should catch it if we add a redundant break and it's in a block.

// X Case statement in tock does not end with break

class Module {
 public:
  logic<8> tock() {
    logic<8> result;
    switch (my_reg) {
      case 0: {
        result = 10;
        break;
        result = 10;
        break;
      }
      default:
        result = 30;
        break;
    }

    tick();
    return result;
  }

 private:
  void tick() { my_reg = my_reg + 1; }

  logic<8> my_reg;
};
#include "metron_tools.h"

// X Context sig1 had invalid state after trace

class Module {
 public:
  void tock1() { sig1 = sig2; }

  void tock2() { sig2 = sig1; }

  void tock3() { sig1 = 0; }

 private:
  logic<8> sig1;
  logic<8> sig2;
};
All the header files in this directory should _not_ be convertible to
SystemVerilog. They should fail for one or more reasons, and the reason texts
are stored in the header file tagged with "//X".
#include "metron_tools.h"

// The tracer should catch it if we forget a break.
// X Case statement in tock does not end with break

class Module {
 public:
  logic<8> tock() {
    logic<8> result;
    switch (my_reg) {
      case 0:  // can we stick comments in here?
      case 1:
      case 2:
        result = 10;
        break;
      case 3: {
        result = 20;
        /*break;*/
      }
      default:
        result = 30;
        break;
    }

    tick();
    return result;
  }

 private:
  void tick() { my_reg = my_reg + 1; }

  logic<8> my_reg;
};
#include "metron_tools.h"

// A submod function can only produce one value per tock(). Trying to use it
// twice should be an error.

// X Context tock_add_one had invalid state after trace

class Submod {
 public:
  logic<8> tock_add_one(logic<8> a) const { return a + 1; }
};

class Module {
 public:
  void tock() {
    b = submod.tock_add_one(b);
    c = submod.tock_add_one(c);
  }

 private:
  logic<8> b;
  logic<8> c;
  Submod submod;
};
#include "metron_tools.h"

// X Constructor for Module is not allowed to have params

class Module {
 public:
  Module(int x) {}
};
#include "metron_tools.h"

// Tock functions can't have more than a single return at the end.

// X Method tock has non-terminal return

class Module {
 public:
  logic<8> tock(logic<8> data) {
    if (data > 10) {
      return 12;
    }
    return 11;
  }
};
#include "metron_tools.h"

// Signals that are written after they're read should fail.

// X Context sig had invalid state after trace

class Module {
 public:
  void tock() {
    sig = 1;
    logic<1> x = sig;
    sig = 0;
  }

  logic<1> sig;
};
#include "metron_tools.h"

// Registers that are read after they're written should fail.

// X Context reg had invalid state after trace

class Module {
 public:
  void tock() { tick(); }

 private:
  void tick() {
    logic<1> x = reg;
    reg = 1;
    logic<1> y = reg;
  }

  logic<1> reg;
};
#include "metron_tools.h"

// The tracer should catch it if we add a redundant break.

// X Case statement in tock does not end with break

class Module {
 public:
  logic<8> tock() {
    logic<8> result;
    switch (my_reg) {
      case 0:
        result = 10;
        break;
        result = 10;
        break;
      default:
        result = 30;
        break;
    }
    tick();
    return result;
  }

 private:
  void tick() { my_reg = my_reg + 1; }

  logic<8> my_reg;
};
#include "metron_tools.h"

// If statements whose sub-blocks contain submodule calls _must_ use {}.

// X If branches that contain component calls must use {}.

class Submod {
 public:
  int my_sig;
  void tock() {
    my_sig = 1;
  }
};

class Module {
 public:

  int my_sig;

  void tock() {
    if (1)
      submod.tock();
    else
      submod.tock();
    my_sig = submod.my_sig;
  }

  Submod submod;
};
#include "metron_tools.h"

// Tick methods are not allowed to have a return value.
// X Tick method Module.tick is not allowed to have a return value.

class Module {
 public:
  logic<2> tick() {
    my_reg = my_reg + 1;
    return 8;
  }

 private:
  logic<2> my_reg;
};
