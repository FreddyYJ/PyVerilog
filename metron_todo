need to trace all methods

PREPROC

void func() {
  static const inst local_constant = N;
}

packed structs are going to behave differently if bitsliced, not sure how to
deal with that... but if you can't express it in c do we care?


treat all call args/return values as fields that have to be traced
  ok now we need test cases

A bunch of the subcursor stuff could be replaced with splice
  probably all of it if you add a component context param to splice

If we don't emit anything for a tick() or tock(), we should not emit the tock itself
  soooooo... if all the body elements are component calls without args?
  not worth

Unions?


do a preproc if else test





Make lockstep test framework for all the metron_good tests
  Make all of them have a toplevel "logic<32> tock();"
  Run for N cycles and check that return values from both
  versions match, but don't care about the actual value.




Coverage
  Err.h
    fine, skip it
  Log.h
    Why is mute() not hitting?
  MetronApp.cpp
    skip if (stats)
    convert && out_root.empty()
    !out_file
  MtCursor.cpp
    // Discard the line if it contained only whitespace after elisions
    Skipping over null node
    emit_assignment Cursor not at end
    emit_static_bit_extract arg0 is suscript expression?
    emit_static_bit_extract Size-casting expression
    Slice width 1
    bx<>
    debugbreaks
    Local call to private tock
    emit_input_port_bindings
      Component method is not public
      Can't find method name
      Method is not private
    Return statement not at end of function body? Remove this
    emit_field_as_enum_class
    emit_port_decls
      all_components.empty()
    emit_field_decl
      emit_field_as_enum_class
      in_ports?
    emit_expression
      child(0).sym == sym_call_expression && current_method->is_tick           
        wat?
    emit_enum_list
    emit_number_literal
      spacers
    emit_if_statement
      "Else statements that contain component calls...
    emit_enum_specifier
    emit_using_decl?
    emit_decl static const
    emit_sized_type_spec
    emit_namespace_def







tests to increase coverage
  bad output dir
  no output dir
  echo
  no source root
  lhs of assignment is array
  sra
  final block?
  all the discrete bit extract sizes
  decl without initialization value
  static const
  emit_field_as_enum_class
  emit_output_ports when current_mod->components.empty()
  non-optional template parameter
  compound statement with a declaration
  emit_template_param_list?
  emit_enum_list
  emit_number_literal with hex and binary literals
  emit_break
  emit_condition - ternary
  emit_qualified_id?
  emit_enum_specifier
  emit_using_decl
  emit_decl static const
  emit_sized_type_spec?
  emit_namespace_def
  most of the emit_preproc branches
  string literal?
  MtModLibrary::reset
  MtModLibrary::find_source
  couldn't find x in path
  MtModule::init - template without params? template without class?
  source file without class
  regs and sigs that end in a bad state?
  duplicate input ports, output ports (somehow?), regs?, components?
  unused Mn - MnIdentifer, MnFieldDeclList, MnTemplateFunc
  modules using primitive C++ types and stdints
  Delete source file objects on shutdown
  prefix and postfix operators - x++ ++x
  trace sym_subscript_expression? handled elsewhere?
  private init
  const init
  const tick
  const tock
  const task


preserving port order test










----------

assert that components are only bound once?
  no, they can be bound multiple times, won't break anything
component calls can only be at toplevel?
  no, but they have to be in a compound statement so we have a place to put bindings

